{
  "neosnippet-snippets/neosnippets": [
    {
      "vital": []
    },
    {
      "vital": [
        {
          "content": "vital#${1:#:plugin_name}#new()",
          "doc": "",
          "grammar": "snu",
          "label": "vital#...#new()",
          "matches": {
            "vital_new_without_let": true
          },
          "options": {}
        },
        {
          "content": "let ${1:s:V} = vital#${2:#:plugin_name}#new()",
          "doc": "",
          "grammar": "snu",
          "label": "let s:V = vital#...#new()",
          "matches": {
            "vital_new": true
          },
          "options": {
            "head": true
          }
        },
        {
          "content": "${1:s:V}.import('${2:#:module_name}')",
          "doc": "",
          "grammar": "snu",
          "label": "s:V.import('...')",
          "matches": {
            "vital_import_without_let": true
          },
          "options": {}
        },
        {
          "content": "let ${1:s:M} = ${2:s:V}.import('${3:#:module_name}')",
          "doc": "",
          "grammar": "snu",
          "label": "let s:M = s:V.import('...')",
          "matches": {
            "vital_import": true
          },
          "options": {
            "head": true
          }
        },
        {
          "content": "${1:s:V}.load('${2:#:module_name}')",
          "doc": "",
          "grammar": "snu",
          "label": "s:V.load('...')",
          "matches": {
            "vital_load_without_call": true
          },
          "options": {}
        },
        {
          "content": "call ${1:s:V}.load('${2:#:module_name}')",
          "doc": "",
          "grammar": "snu",
          "label": "call s:V.load('...')",
          "matches": {
            "vital_load": true
          },
          "options": {
            "head": true
          }
        }
      ]
    }
  ],
  "rocketseat-vscode-react-native-snippets/snippets": [
    {
      "snippets-ts": []
    },
    {
      "snippets-ts": [
        {
          "content": "import styled from 'styled-components/native';\n\nexport const ${1:Container} = styled.${2:View}`\n  ${3}\n`;\n",
          "doc": "Create React Native Styled Components file",
          "grammar": "lsp",
          "label": "styles",
          "matches": {
            "styled-react-native": true
          },
          "options": {}
        }
      ]
    }
  ],
  "snipsnap/snippets": [
    {
      "angular": []
    },
    {
      "angular": [
        {
          "content": "# Client App\nFROM johnpapa/angular-cli as client-app\nLABEL authors=\"${1:John Papa}\"\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --silent\nCOPY . .\nRUN ng build --prod\n\n# Node server\nFROM ${2:node:12-alpine} as node-server\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --production --silent && mv node_modules ../\nCOPY ${3:server.js} .\nCOPY ${4:/server} /usr/src/app/server\n\n# Final image\nFROM ${2:node:12-alpine}\nWORKDIR /usr/src/app\nCOPY --from=node-server /usr/src /usr/src\nCOPY --from=client-app /usr/src/app/dist ./\nEXPOSE ${5:3000}\n# CMD [\"node\", \"server.js\"]\nCMD [\"npm\", \"start\"]\n$0",
          "doc": "Multi-stage Node and Angular Dockerfile",
          "grammar": "lsp",
          "label": "multi-stage-node-and-angular-dockerfile",
          "matches": {
            "angular multi-stage node and dockerfile": true,
            "docker-angular-node-multi-stage": true
          },
          "options": {}
        },
        {
          "content": "[class]=\"${1:expression}\"",
          "doc": "Angular [class] binding",
          "grammar": "lsp",
          "label": "class",
          "matches": {
            "a-class": true,
            "angular class": true
          },
          "options": {}
        },
        {
          "content": "[style.${1:property}]=\"${2:expression}\"",
          "doc": "Angular [style] binding",
          "grammar": "lsp",
          "label": "style",
          "matches": {
            "a-style": true,
            "angular style": true
          },
          "options": {}
        },
        {
          "content": "[ngClass]=\"{${1:cssClass}: ${2:expression}}\"",
          "doc": "Angular ngClass",
          "grammar": "lsp",
          "label": "ngclass",
          "matches": {
            "a-ngclass": true,
            "angular ng class": true
          },
          "options": {}
        },
        {
          "content": "*ngFor=\"let ${1:item} of ${2:list}\"${0}",
          "doc": "Angular *ngFor",
          "grammar": "lsp",
          "label": "ngfor",
          "matches": {
            "a-ngfor": true,
            "angular ng for": true
          },
          "options": {}
        },
        {
          "content": "*ngFor=\"let ${1:item} of ${2:list}; trackBy:${1:item}.id\"${0}",
          "doc": "Angular *ngFor with trackBy",
          "grammar": "lsp",
          "label": "ngfor-with-trackby",
          "matches": {
            "a-ngfor-trackby": true,
            "angular ng for with track by": true
          },
          "options": {}
        },
        {
          "content": "*ngFor=\"let ${1:item} of ${2:stream} | async as ${3:list}\"${0}",
          "doc": "Angular *ngForAsync",
          "grammar": "lsp",
          "label": "ngforasync",
          "matches": {
            "a-ngforasync": true,
            "angular ng for async": true
          },
          "options": {}
        },
        {
          "content": "<form (ngSubmit)=\"onSubmit()\" #${1:form}=\"ngForm\">\n</form>",
          "doc": "Form with ngSubmit and form attributes",
          "grammar": "lsp",
          "label": "ngform",
          "matches": {
            "a-form": true,
            "angular ng form": true
          },
          "options": {}
        },
        {
          "content": "formArrayName=\"${1:control}\"",
          "doc": "Angular formArrayName",
          "grammar": "lsp",
          "label": "ngformarrayname",
          "matches": {
            "a-formarrayname": true,
            "angular ng form array name": true
          },
          "options": {}
        },
        {
          "content": "formControlName=\"${1:control}\"",
          "doc": "Angular formControlName",
          "grammar": "lsp",
          "label": "ngformcontrolname",
          "matches": {
            "a-formcontrolname": true,
            "angular ng form control name": true
          },
          "options": {}
        },
        {
          "content": "[formGroup]=\"${1:form}\"",
          "doc": "Angular formGroup",
          "grammar": "lsp",
          "label": "ngformgroup",
          "matches": {
            "a-formgroup": true,
            "angular ng form group": true
          },
          "options": {}
        },
        {
          "content": "[formGroupName]=\"${1:name}\"",
          "doc": "Angular formGroupName",
          "grammar": "lsp",
          "label": "ngformgroupname",
          "matches": {
            "a-formgroupname": true,
            "angular ng form group name": true
          },
          "options": {}
        },
        {
          "content": "<button type=\"submit\" [disabled]=\"!${1:form}.form.valid\">\n\tSave\n</button>",
          "doc": "Angular form submit",
          "grammar": "lsp",
          "label": "ngformsubmit",
          "matches": {
            "a-form-submit": true,
            "angular ng form submit": true
          },
          "options": {}
        },
        {
          "content": "*ngIf=\"${1:expression}\"",
          "doc": "Angular *ngIf",
          "grammar": "lsp",
          "label": "ngif",
          "matches": {
            "a-ngif": true,
            "angular ng if": true
          },
          "options": {}
        },
        {
          "content": "*ngIf=\"${1:expression};else ${2:templateName}\"",
          "doc": "Angular *ngIfElse",
          "grammar": "lsp",
          "label": "ngifelse",
          "matches": {
            "a-ngifelse": true,
            "angular ng if else": true
          },
          "options": {}
        },
        {
          "content": "[(ngModel)]=\"${1:binding}\"",
          "doc": "Angular ngModel",
          "grammar": "lsp",
          "label": "ngmodel",
          "matches": {
            "a-ngmodel": true,
            "angular ng model": true
          },
          "options": {}
        },
        {
          "content": "[routerLink]=\"['/${1:routePath}']\" routerLinkActive=\"${2:router-link-active}\" $0",
          "doc": "Angular routerLink",
          "grammar": "lsp",
          "label": "ngrouterlink",
          "matches": {
            "a-routerlink": true,
            "angular ng router link": true
          },
          "options": {}
        },
        {
          "content": "[routerLink]=\"['${1:routePath}', ${2:routeParameterValue}]\"\nrouterLinkActive=\"${3:router-link-active}\"$0",
          "doc": "Angular routerLink with a route parameter",
          "grammar": "lsp",
          "label": "ngrouterlinkwithparameter",
          "matches": {
            "a-routerlink-param": true,
            "angular ng router link with parameter": true
          },
          "options": {}
        },
        {
          "content": "<select [(ngModel)]=\"${1:model}\">\n\t<option *ngFor=\"let ${2:item} of ${3:list}\" [value]=\"${2:item}\">{{${2:item}}}</option>\n</select>",
          "doc": "<select> control with ngModel",
          "grammar": "lsp",
          "label": "ngselect",
          "matches": {
            "a-select": true,
            "angular ng select": true
          },
          "options": {}
        },
        {
          "content": "[ngStyle]=\"{${1:style}: ${2:expression}}\"",
          "doc": "Angular ngStyle",
          "grammar": "lsp",
          "label": "ngstyle",
          "matches": {
            "a-ngstyle": true,
            "angular ng style": true
          },
          "options": {}
        },
        {
          "content": "<div [ngSwitch]=\"${1:conditionExpression}\">\n\t<div *ngSwitchCase=\"${2:expression}\">${3:output}</div>\n\t<div *ngSwitchDefault>${4:output2}</div>\n</div>",
          "doc": "Angular ngSwitch",
          "grammar": "lsp",
          "label": "ngswitch",
          "matches": {
            "a-ngswitch": true,
            "angular ng switch": true
          },
          "options": {}
        },
        {
          "content": "<pre>{{${1:model} | json}}</pre>$0",
          "doc": "Angular pre debug | json",
          "grammar": "lsp",
          "label": "pre-w-json",
          "matches": {
            "a-prej": true,
            "angular pre json": true
          },
          "options": {}
        },
        {
          "content": "<pre>{{${1:model} | async | json}}</pre>$0",
          "doc": "Angular pre debug | async | json",
          "grammar": "lsp",
          "label": "pre-w-async-json",
          "matches": {
            "a-preja": true,
            "angular pre async json": true
          },
          "options": {}
        },
        {
          "content": "<ng-container $0></ng-container>",
          "doc": "Angular ng-container",
          "grammar": "lsp",
          "label": "ng-container",
          "matches": {
            "a-ng-container": true,
            "angular ng-container": true
          },
          "options": {}
        },
        {
          "content": "<ng-template [ngTemplateOutlet]=\"${1:outlet}\" [ngOutletContext]=\"${2:context}\"></ng-template>",
          "doc": "Angular ng-template",
          "grammar": "lsp",
          "label": "ng-template",
          "matches": {
            "a-ng-template": true,
            "angular ng-template": true
          },
          "options": {}
        },
        {
          "content": "<ng-content select=\"${0:selector}\"></ng-content>",
          "doc": "Angular ng-content",
          "grammar": "lsp",
          "label": "ng-content",
          "matches": {
            "a-ng-content": true,
            "angular ng-content": true
          },
          "options": {}
        },
        {
          "content": "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || ${1:port};\nconst www = process.env.WWW || '${2:./}';\napp.use(express.static(www));\nconsole.log(`serving \\${www}`);\napp.get('*', (req, res) => {\n\tres.sendFile(`index.html`, { root: www });\n});\napp.listen(port, () => console.log(`listening on http://localhost:\\${port}`));\n$0",
          "doc": "Node.js Express Server",
          "grammar": "lsp",
          "label": "node-js-express-server",
          "matches": {
            "angular node express server": true,
            "ex-node-server-simple": true
          },
          "options": {}
        },
        {
          "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplateUrl: '${2:name}.component.html'\n})\n\nexport class ${3:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }$0\n}",
          "doc": "Angular component",
          "grammar": "lsp",
          "label": "angular-component",
          "matches": {
            "a-component": true,
            "angular component": true
          },
          "options": {}
        },
        {
          "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplate: `$0`\n})\n\nexport class ${2:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }\n}",
          "doc": "Angular component with an inline template",
          "grammar": "lsp",
          "label": "angular-component-with-inline-template",
          "matches": {
            "a-component-inline": true,
            "angular component inline template": true
          },
          "options": {}
        },
        {
          "content": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n\tname: '${1:selector-name}'\n})\n\nexport class ${2:Name}Pipe implements PipeTransform {\n\ttransform(value: any, ...args: any[]): any {\n\t\t$0\n\t}\n}",
          "doc": "Angular pipe",
          "grammar": "lsp",
          "label": "angular-pipe",
          "matches": {
            "a-pipe": true,
            "angular pipe": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor() { }\n\t$0\n}",
          "doc": "Angular Service with Injectable ProvidedIn Root",
          "grammar": "lsp",
          "label": "angular-service",
          "matches": {
            "a-service": true,
            "angular service": true
          },
          "options": {}
        },
        {
          "content": "{ path: '', pathMatch: 'full', redirectTo: '${1:path}' }$0",
          "doc": "Angular default route path",
          "grammar": "lsp",
          "label": "angular-default-route-path",
          "matches": {
            "a-route-path-default": true,
            "angular default route path": true
          },
          "options": {}
        },
        {
          "content": "{\n\tpath: '${1:path}', \n\tcomponent: ${2:Component},\n\tchildren: [\n\t\t{ path: '${3:childpath}', component: ${4:ChildComponent} }\n\t]\n}$0",
          "doc": "Angular route path with children",
          "grammar": "lsp",
          "label": "angular-route-path-with-children",
          "matches": {
            "a-route-path-with-children": true,
            "angular route path children": true
          },
          "options": {}
        },
        {
          "content": "{ path: '**', component: ${1:PathNotFoundComponent} }$0",
          "doc": "Angular 404 route path",
          "grammar": "lsp",
          "label": "angular-404-route-path",
          "matches": {
            "a-route-path-404": true,
            "angular 404 route path": true
          },
          "options": {}
        },
        {
          "content": "{ path: '${1:path}', component: ${2:Name}Component },",
          "doc": "Angular eager route path",
          "grammar": "lsp",
          "label": "angular-eager-route-path",
          "matches": {
            "a-route-path-eager": true,
            "angular eager route path": true
          },
          "options": {}
        },
        {
          "content": "{\n\tpath: '${1:path}', \n\tloadChildren: () => import('${2:lazy-path}').then(m => m.${3:lazy-module})\n},",
          "doc": "Angular lazy route path",
          "grammar": "lsp",
          "label": "angular-lazy-route-path",
          "matches": {
            "a-route-path-lazy": true,
            "angular lazy route path": true
          },
          "options": {}
        },
        {
          "content": "this.route.paramMap\n\t.pipe(switchMap(params => params.get('id')), tap(id => (this.id = +id)))\n\t.subscribe(id => {$1});\n$0",
          "doc": "Angular - subscribe to routing parameters",
          "grammar": "lsp",
          "label": "routing-params-subscribe",
          "matches": {
            "a-route-params-subscribe": true,
            "angular routing params subscribe": true
          },
          "options": {}
        },
        {
          "content": "return this.httpClient.get('${1:url}');$0",
          "doc": "Angular HttpClient.get",
          "grammar": "lsp",
          "label": "httpclient-get",
          "matches": {
            "a-httpclient-get": true,
            "angular http client get": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor(private httpClient: HttpClient) { }\n\t$0\n}",
          "doc": "Angular service with HttpClient",
          "grammar": "lsp",
          "label": "angular-httpclient-service",
          "matches": {
            "a-service-httpclient": true,
            "angular http client service": true
          },
          "options": {}
        },
        {
          "content": "import { HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LogInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst started = Date.now();\n\t\treturn next.handle(req).pipe(\n\t\t\ttap(event => {\n\t\t\t\tif (event instanceof HttpResponse) {\n\t\t\t\t\tconst elapsed = Date.now() - started;\n\t\t\t\t\tconsole.log(`Request for \\${req.urlWithParams} took \\${elapsed} ms.`);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}",
          "doc": "Angular HttpInterceptor for Logging HttpClient",
          "grammar": "lsp",
          "label": "angular-httpinterceptor-for-logging",
          "matches": {
            "a-http-interceptor-logging": true,
            "angular http interceptor logging": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeaderInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst headers = req.headers\n\t\t\t.set('Content-Type', 'application/json');\n\t\tconst authReq = req.clone({ headers });\n\t\treturn next.handle(authReq);\n\t}\n}",
          "doc": "Angular HttpInterceptor for headers HttpClient",
          "grammar": "lsp",
          "label": "angular-httpinterceptor-for-headers",
          "matches": {
            "a-http-interceptor-headers": true,
            "angular http interceptor headers": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpEvent, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class ${2:Your}Interceptor implements HttpInterceptor {\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\treturn next.handle(req);\n\t}\n}",
          "doc": "Empty Angular HttpInterceptor for HttpClient",
          "grammar": "lsp",
          "label": "angular-httpinterceptor-empty",
          "matches": {
            "a-http-interceptor": true,
            "angular http interceptor empty": true
          },
          "options": {}
        },
        {
          "content": "@Output() ${1:eventName} = new EventEmitter<${2:eventType}>();",
          "doc": "Angular @Output event and emitter",
          "grammar": "lsp",
          "label": "output-event",
          "matches": {
            "a-output-event": true,
            "angular output event": true
          },
          "options": {}
        },
        {
          "content": "this.${1:service}.${2:function}\n\t.subscribe(${3:arg} => this.${4:property} = ${3:arg});\n$0",
          "doc": "Angular observable subscribe",
          "grammar": "lsp",
          "label": "subscribe",
          "matches": {
            "a-subscribe": true,
            "angular subscribe": true
          },
          "options": {}
        },
        {
          "content": "import { Component } from '@angular/core';\n\n@Component({\n\tselector: '${1:prefix-app}',\n\ttemplate: `\n\t\t<router-outlet></router-outlet>\n\t\t`\n})\nexport class ${2:App}Component { }\n$0",
          "doc": "Angular App root component",
          "grammar": "lsp",
          "label": "angular-root-component",
          "matches": {
            "a-component-root": true,
            "angular root component": true
          },
          "options": {}
        },
        {
          "content": "import { NgModule } from '@angular/core';\nimport { BrowserModule  } from '@angular/platform-browser';\nimport { HttpModule } from '@angular/http';\n\nimport { ${1:App}Component } from './${1:app}.component';\n\n@NgModule({\n\timports: [\n\t\tBrowserModule,\n\t\tHttpModule,\n\t],\n\tdeclarations: [${1:App}Component],\n\tbootstrap: [${1:App}Component],\n})\nexport class ${1:App}Module { }\n$0",
          "doc": "Angular Root Module",
          "grammar": "lsp",
          "label": "angular-root-module",
          "matches": {
            "a-module-root": true,
            "angular root module": true
          },
          "options": {}
        },
        {
          "content": "import { Routes } from '@angular/router';\n\nexport const routes: Routes = [${0}]",
          "doc": "Route definitions",
          "grammar": "lsp",
          "label": "route-definitions",
          "matches": {
            "a-routes": true,
            "angular route definitions": true
          },
          "options": {}
        },
        {
          "content": "import { NgModule } from '@angular/core';\n\nimport { ${1:Name}Component } from './${2:name}.component';\n\n@NgModule({\n\timports: [],\n\texports: [],\n\tdeclarations: [${1:Name}Component],\n\tproviders: [],\n})\nexport class ${1:Name}Module { }\n$0",
          "doc": "Angular Module",
          "grammar": "lsp",
          "label": "angular-module",
          "matches": {
            "a-module": true,
            "angular module": true
          },
          "options": {}
        },
        {
          "content": "import { Directive } from '@angular/core';\n\n@Directive({ selector: '[${1:selector-name}]' })\nexport class ${2:Name}Directive {\n\tconstructor() { }\n}",
          "doc": "Angular directive",
          "grammar": "lsp",
          "label": "angular-directive",
          "matches": {
            "a-directive": true,
            "angular directive": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivate, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivate {\n\tconstructor() { }\n\n\tcanActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
          "doc": "Angular CanActivate guard",
          "grammar": "lsp",
          "label": "angular-canactivate-guard",
          "matches": {
            "a-guard-can-activate": true,
            "angular can activate guard": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivateChild, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivateChild {\n\tconstructor() { }\n\n\tcanActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
          "doc": "Angular CanActivateChild guard",
          "grammar": "lsp",
          "label": "angular-canactivatechild-guard",
          "matches": {
            "a-guard-can-activate-child": true,
            "angular can activate child guard": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { CanLoad, Route } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanLoad {\n\tconstructor() { }\n\n\tcanLoad(route: Route) {\n\t\treturn true;$0\n\t}\n}",
          "doc": "Angular CanLoad guard",
          "grammar": "lsp",
          "label": "angular-canload-guard",
          "matches": {
            "a-guard-can-load": true,
            "angular can load guard": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanDeactivate, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { ${2:ComponentName}Component } from './${3:filename}.component';\n\n// Consider using this interface for all CanDeactivate guards,\n// and have your components implement this interface, too.\n//\n//   e.g. export class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {\n//\n// export interface CanComponentDeactivate {\n// canDeactivate: () => any;\n// }\n\n@Injectable({providedIn: ${4:'root'}})\nexport class ${1:Name}Guard implements CanDeactivate<${2:ComponentName}Component> {\n\tcanDeactivate(\n\t\tcomponent: ${2:ComponentName}Component,\n\t\tcurrentRoute: ActivatedRouteSnapshot, \n\t\tcurrentState: RouterStateSnapshot\n\t): Observable<boolean>|Promise<boolean>|boolean {\n\t\treturn false;$0\n\t}\n}",
          "doc": "Angular CanDeactivate guard",
          "grammar": "lsp",
          "label": "angular-candeactivate-guard",
          "matches": {
            "a-guard-can-deactivate": true,
            "angular can deactivate guard": true
          },
          "options": {}
        },
        {
          "content": "import { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nexport class PreloadSelectedModulesList implements PreloadingStrategy {\n\tpreload(route: Route, load: Function): Observable<any> {\n\t\treturn route.data && route.data['${1:preload}'] ? load() : of(null);\n\t}\n}\n$0",
          "doc": "Angular opt-in preload strategy",
          "grammar": "lsp",
          "label": "angular-opt-in-preload-strategy",
          "matches": {
            "a-preload-opt-in-strategy": true,
            "angular opt-in preload strategy": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, EMPTY } from 'rxjs';\n\n// avoid typing issues for now\nexport declare var navigator;\n\n@Injectable({ providedIn: 'root' })\nexport class NetworkAwarePreloadStrategy implements PreloadingStrategy {\n\tpreload(route: Route, load: () => Observable<any>): Observable<any> {\n\t\treturn this.hasGoodConnection() ? load() : EMPTY;\n\t}\n\n\thasGoodConnection(): boolean {\n\t\tconst conn = navigator.connection;\n\t\tif (conn) {\n\t\t\tif (conn.saveData) {\n\t\t\t\treturn false; // save data mode is enabled, so dont preload\n\t\t\t}\n\t\t\tconst avoidTheseConnections = ['slow-2g', '2g' /* , '3g', '4g' */];\n\t\t\tconst effectiveType = conn.effectiveType || '';\n\t\t\tif (avoidTheseConnections.includes(effectiveType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}",
          "doc": "Angular network aware preload strategy",
          "grammar": "lsp",
          "label": "angular-network-aware-preload-strategy",
          "matches": {
            "a-preload-network-strategy": true,
            "angular network-aware preload strategy": true
          },
          "options": {}
        },
        {
          "content": "checkEvents() {\n\tthis.router.events.subscribe(event => {\n\t\tswitch (true) {\n\t\t\tcase event instanceof ${1:eventName}:\n\t\t\t\t$0\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t});\n}",
          "doc": "Angular Router Events",
          "grammar": "lsp",
          "label": "angular-router-events",
          "matches": {
            "a-router-events": true,
            "angular router events": true
          },
          "options": {}
        },
        {
          "content": "constructor( @Optional() @SkipSelf() parentModule: ${1:ModuleName} {\n\tif (parentModule) {\n\t\tconst msg = `${1:ModuleName} has already been loaded. \n\t\t\tImport ${1:ModuleName} once, only, in the root AppModule.`;\n\t\tthrow new Error(msg);\n\t}\n}",
          "doc": "Angular Module SkipSelf constructor",
          "grammar": "lsp",
          "label": "angular-module-skipself-constructor",
          "matches": {
            "a-ctor-skip-self": true,
            "angular module skip self constructor": true
          },
          "options": {}
        },
        {
          "content": "import { ${1:Observable} } from 'rxjs';\n$0",
          "doc": "RxJs import",
          "grammar": "lsp",
          "label": "rxjs-import",
          "matches": {
            "a-rxjs-import": true,
            "angular import rx js": true
          },
          "options": {}
        },
        {
          "content": "import { ${1:map} } from 'rxjs/operators';\n$0",
          "doc": "RxJs import",
          "grammar": "lsp",
          "label": "rxjs-operator-import",
          "matches": {
            "a-rxjs-operator-import": true,
            "angular import rx js operator": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { Resolve, ActivatedRouteSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: ${1:'root'} })\nexport class ${2:YourResolver} implements Resolve<${3:ObjectToResolve}> {\n\tresolve(route: ActivatedRouteSnapshot): Observable<${3:ObjectToResolve}> | Promise<${3:ObjectToResolve}> | ${3:ObjectToResolve} {\n\t\treturn ${0};\n\t}\n}",
          "doc": "Angular Resolver",
          "grammar": "lsp",
          "label": "angular-resolver",
          "matches": {
            "a-resolver": true,
            "angular resolver": true
          },
          "options": {}
        },
        {
          "content": "import { NgModule } from '@angular/core';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreModule } from '@ngrx/store';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { environment } from '../../environments/environment';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot({}),\n    EffectsModule.forRoot([]),\n    environment.production ? [] : StoreDevtoolsModule.instrument()\n  ]\n})\nexport class $1StoreModule {}",
          "doc": "NgRx Store Module",
          "grammar": "lsp",
          "label": "ngrx-store-module",
          "matches": {
            "a-ngrx-store-module": true,
            "angular ng rx store module": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}');",
          "doc": "Creates an NgRx Action",
          "grammar": "lsp",
          "label": "ngrx-create-action",
          "matches": {
            "a-ngrx-create-action": true,
            "angular ng rx create action": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}', props<{${4:key}: ${5:type}}>());",
          "doc": "Creates an NgRx Action with Props",
          "grammar": "lsp",
          "label": "ngrx-create-action-w-props",
          "matches": {
            "a-ngrx-create-action-props": true,
            "angular ng rx create action props": true
          },
          "options": {}
        },
        {
          "content": "const ${1:feature}Reducer = createReducer(\n\tinitialState,\n\ton($1Actions.action, state => ({ ...state, ${2:prop}: ${3:updatedValue} })),\n);\n\nexport function reducer(state: State | undefined, action: Action) {\n\treturn $1Reducer(state, action);\n}",
          "doc": "Creates an NgRx Reducer",
          "grammar": "lsp",
          "label": "ngrx-create-reducer",
          "matches": {
            "a-ngrx-create-reducer": true,
            "angular ng rx create reducer": true
          },
          "options": {}
        },
        {
          "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State) => state.${3:property}\n);",
          "doc": "Creates an NgRx Selector",
          "grammar": "lsp",
          "label": "ngrx-create-selector",
          "matches": {
            "a-ngrx-create-selector": true,
            "angular ng rx create selector": true
          },
          "options": {}
        },
        {
          "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State, props) => ${3:selectLogic}\n);",
          "doc": "Creates an NgRx Selector using props",
          "grammar": "lsp",
          "label": "ngrx-create-selector-w-props",
          "matches": {
            "a-ngrx-create-selector-props": true,
            "angular ng rx create selector props": true
          },
          "options": {}
        },
        {
          "content": "EntityDataModule.forRoot(${1:entityConfig}),",
          "doc": "Import NgRx Entity Data Module",
          "grammar": "lsp",
          "label": "ngrx-data-import-entity-data-module",
          "matches": {
            "a-ngrx-data-entity-data-module-import": true,
            "angular ng rx data import entity module": true
          },
          "options": {}
        },
        {
          "content": "import { EntityMetadataMap } from '@ngrx/data';\n\nconst entityMetadata: EntityMetadataMap = {\n  ${1:Model1}: {},${0}\n};\n\nexport const entityConfig = {\n  entityMetadata\n};",
          "doc": "NgRx Data Entity Metadata",
          "grammar": "lsp",
          "label": "ngrx-data-entity-metadata",
          "matches": {
            "a-ngrx-data-entity-metadata": true,
            "angular ng rx data entity metadata": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport {\n  EntityCollectionServiceBase,\n  EntityCollectionServiceElementsFactory\n} from '@ngrx/data';\nimport { ${1:Model} } from '${2:../core}';\n\n@Injectable({ providedIn: ${3:'root'} })\nexport class ${1:Model}Service extends EntityCollectionServiceBase<${1:Model}> {\n  constructor(serviceElementsFactory: EntityCollectionServiceElementsFactory) {\n    super('${1:Model}', serviceElementsFactory);\n  }\n}",
          "doc": "NgRx Data Entity Collection Data Service",
          "grammar": "lsp",
          "label": "ngrx-data-entity-collection-data-service",
          "matches": {
            "a-ngrx-data-entity-collection-data-service": true,
            "angular ng rx data entity collection service": true
          },
          "options": {}
        },
        {
          "content": "${1:trackBy}(index: number, ${2:name}: ${3:model}): ${4:number} {\n  return ${2:name}${5:.id};$0\n}",
          "doc": "TrackBy Function",
          "grammar": "lsp",
          "label": "trackby-function",
          "matches": {
            "a-trackby": true,
            "angular track by function": true
          },
          "options": {}
        }
      ]
    }
  ],
  "vim-go/gosnippets/UltiSnips": [
    {
      "go": []
    },
    {
      "go": [
        {
          "content": "${1} := ${0}",
          "doc": "",
          "grammar": "snu",
          "label": "v := value",
          "matches": {
            ":": true
          },
          "options": {}
        },
        {
          "content": "${1:fn} := func() {\n\t${2:${VISUAL}}\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "fn := func() { ... }",
          "matches": {
            "anon": true
          },
          "options": {}
        },
        {
          "content": "append(${1:slice}, ${0:value})",
          "doc": "",
          "grammar": "snu",
          "label": "append(slice, value)",
          "matches": {
            "ap": true
          },
          "options": {}
        },
        {
          "content": "${1:slice} = append($1, ${0:value})",
          "doc": "",
          "grammar": "snu",
          "label": "a = append(a, value)",
          "matches": {
            "ap=": true
          },
          "options": {}
        },
        {
          "content": "break",
          "doc": "",
          "grammar": "snu",
          "label": "break",
          "matches": {
            "br": true
          },
          "options": {}
        },
        {
          "content": "chan ${0:int}",
          "doc": "",
          "grammar": "snu",
          "label": "chan Type",
          "matches": {
            "ch": true
          },
          "options": {}
        },
        {
          "content": "case ${1:value}:\n\t${0:${VISUAL}}",
          "doc": "",
          "grammar": "snu",
          "label": "case ...:",
          "matches": {
            "case": true
          },
          "options": {}
        },
        {
          "content": "const ${1:NAME} ${2:Type} = ${0:0}",
          "doc": "",
          "grammar": "snu",
          "label": "const XXX Type = ...",
          "matches": {
            "con": true
          },
          "options": {}
        },
        {
          "content": "const (\n\t${1:NAME} ${2:Type} = ${3:value}\n\t${0}\n)",
          "doc": "",
          "grammar": "snu",
          "label": "const ( ... )",
          "matches": {
            "cons": true
          },
          "options": {}
        },
        {
          "content": "const (\n\t${1:NAME} ${2:Type} = iota\n\t${0}\n)",
          "doc": "",
          "grammar": "snu",
          "label": "const ( ... = iota )",
          "matches": {
            "iota": true
          },
          "options": {}
        },
        {
          "content": "continue",
          "doc": "",
          "grammar": "snu",
          "label": "continue",
          "matches": {
            "cn": true
          },
          "options": {}
        },
        {
          "content": "default:\n\t${0:${VISUAL}}",
          "doc": "",
          "grammar": "snu",
          "label": "default: ...",
          "matches": {
            "default": true
          },
          "options": {}
        },
        {
          "content": "defer ${1:func}(${2})\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "defer someFunction()",
          "matches": {
            "df": true
          },
          "options": {}
        },
        {
          "content": "defer func() {\n\t${0:${VISUAL}}\n}()",
          "doc": "",
          "grammar": "snu",
          "label": "defer func() { ... }",
          "matches": {
            "def": true
          },
          "options": {}
        },
        {
          "content": "defer func() {\n\tif err := recover(); err != nil {\n\t\t${0:${VISUAL}}\n\t}\n}()",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "defr": true
          },
          "options": {}
        },
        {
          "content": "import (\n\t\"${1:package}\"\n)",
          "doc": "",
          "grammar": "snu",
          "label": "import ( ... )",
          "matches": {
            "import": true
          },
          "options": {}
        },
        {
          "content": "type ${1:Interface} interface {\n\t${2:/* TODO: add methods */}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "interface I { ... }",
          "matches": {
            "interface": true
          },
          "options": {}
        },
        {
          "content": "if ${1:condition} {\n\t${0:${VISUAL}}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if ... { ... }",
          "matches": {
            "if": true
          },
          "options": {}
        },
        {
          "content": "else {\n\t${0:${VISUAL}}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "else": true
          },
          "options": {}
        },
        {
          "content": "if err := ${1:condition}; err != nil {\n\t${0:${VISUAL}}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "If with inline error",
          "matches": {
            "ife": true
          },
          "options": {}
        },
        {
          "content": "errors.Wrap(${1:err}, \"${2:message}\")",
          "doc": "",
          "grammar": "snu",
          "label": "errors.Wrap",
          "matches": {
            "ew": true
          },
          "options": {}
        },
        {
          "content": "errors.Wrapf(${1:err}, \"${2:message %v}\", ${3:args...})",
          "doc": "",
          "grammar": "snu",
          "label": "errors.Wrapf",
          "matches": {
            "ewf": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n\treturn err\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error return",
          "matches": {
            "errn": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\treturn errors.Wrap(err, \"${1:message}\")\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error return wrap",
          "matches": {
            "errnw": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\treturn errors.Wrapf(err, \"${1:message %v}\", ${2:args...})\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error return wrapf",
          "matches": {
            "errnwf": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\tlog.Fatal(err)\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error with log.Fatal(err)",
          "matches": {
            "errl": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\treturn ${1:nil}, ${2:err}\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error return with two return values",
          "matches": {
            "errn,": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\treturn nil, errors.Wrap(err, \"${1:message}\")\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error return wrap with two return values",
          "matches": {
            "errn,w": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\treturn nil, errors.Wrapf(err, \"${1:message %v}\", ${2:args...})\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error return wrapf with two return values",
          "matches": {
            "errn,wf": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\tpanic(${1})\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error panic",
          "matches": {
            "errp": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\tt.Fatal(err)\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error test fatal ",
          "matches": {
            "errt": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\t${1}\n\treturn\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "Error handle and return",
          "matches": {
            "errh": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "fallthrough",
          "doc": "",
          "grammar": "snu",
          "label": "fallthrough",
          "matches": {
            "ft": true
          },
          "options": {}
        },
        {
          "content": "for ${1} {\n\t${0:${VISUAL}}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "for ... { ... }",
          "matches": {
            "for": true
          },
          "options": {}
        },
        {
          "content": "for ${1:i} := 0; $1 < ${2:N}; $1++ {\n\t${0:${VISUAL}}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "for 0..N-1 { ... }",
          "matches": {
            "fori": true
          },
          "options": {}
        },
        {
          "content": "for ${2:k}, ${3:v} := range ${1} {\n\t${0:${VISUAL}}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "for k, v := range items { ... }",
          "matches": {
            "forr": true
          },
          "options": {}
        },
        {
          "content": "for {\n\tselect {\n\t\tcase ${2:${1:result} := }<- ${3:channel}:\n\t\t\t${0}\n\t}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "for select",
          "matches": {
            "forsel": true
          },
          "options": {}
        },
        {
          "content": "case ${1:${2:var} := }<-${3:channel}:\n  ${0}",
          "doc": "",
          "grammar": "snu",
          "label": "select case",
          "matches": {
            "selc": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "fmt.Printf(\"$1 = %+v\\n\", ${1:${VISUAL}})",
          "doc": "",
          "grammar": "snu",
          "label": "fmt.Printf(...)",
          "matches": {
            "ff": true
          },
          "options": {}
        },
        {
          "content": "fmt.Printf(\"$1 = %#v\\n\", ${1:${VISUAL}})",
          "doc": "",
          "grammar": "snu",
          "label": "fmt.Printf(#...) hash",
          "matches": {
            "ffh": true
          },
          "options": {}
        },
        {
          "content": "fmt.Println(\"${1:${VISUAL}}\")",
          "doc": "",
          "grammar": "snu",
          "label": "fmt.Println(...)",
          "matches": {
            "fn": true
          },
          "options": {}
        },
        {
          "content": "fmt.Errorf(\"${1:${VISUAL}}\")",
          "doc": "",
          "grammar": "snu",
          "label": "fmt.Errorf(...)",
          "matches": {
            "fe": true
          },
          "options": {}
        },
        {
          "content": "log.Printf(\"${1:${VISUAL}} = %+v\\n\", $1)",
          "doc": "",
          "grammar": "snu",
          "label": "log.Printf(...)",
          "matches": {
            "lf": true
          },
          "options": {}
        },
        {
          "content": "log.Println(\"${1:${VISUAL}}\")",
          "doc": "",
          "grammar": "snu",
          "label": "log.Println(...)",
          "matches": {
            "ln": true
          },
          "options": {}
        },
        {
          "content": "make(${1:[]string}, ${2:0})${0}",
          "doc": "",
          "grammar": "snu",
          "label": "make(Type, size)",
          "matches": {
            "make": true
          },
          "options": {}
        },
        {
          "content": "map[${1:string}]${0:int}",
          "doc": "",
          "grammar": "snu",
          "label": "map[Type]Type",
          "matches": {
            "map": true
          },
          "options": {}
        },
        {
          "content": "func main() {\n\t${0:${VISUAL}}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "func main() { ... }",
          "matches": {
            "main": true
          },
          "options": {}
        },
        {
          "content": "if !ok {\n\t${0:${VISUAL}}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if !ok { ... }",
          "matches": {
            "ok": true
          },
          "options": {}
        },
        {
          "content": "// Package $1 provides ${2:...}\npackage ${1:main}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "package ...",
          "matches": {
            "package": true
          },
          "options": {}
        },
        {
          "content": "panic(\"${0:msg}\")",
          "doc": "",
          "grammar": "snu",
          "label": "panic()",
          "matches": {
            "pn": true
          },
          "options": {}
        },
        {
          "content": "return ${0:${VISUAL}}",
          "doc": "",
          "grammar": "snu",
          "label": "return",
          "matches": {
            "rt": true
          },
          "options": {}
        },
        {
          "content": "select {\ncase ${1:v1} := <-${2:chan1}:\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "select { case a := <-chan: ... }",
          "matches": {
            "select": true
          },
          "options": {}
        },
        {
          "content": "type ${1:Type} struct {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "type T struct { ... }",
          "matches": {
            "st": true
          },
          "options": {}
        },
        {
          "content": "switch ${1:var} {\ncase ${2:value1}:\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "switch x { ... }",
          "matches": {
            "switch": true
          },
          "options": {}
        },
        {
          "content": "switch ${2:$1 := }${1:v}.(type) {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "type switch x { ... }",
          "matches": {
            "tswitch": true
          },
          "options": {}
        },
        {
          "content": "fmt.Sprintf(\"%${1:s}\", ${2:var})",
          "doc": "",
          "grammar": "snu",
          "label": "fmt.Sprintf(...)",
          "matches": {
            "sp": true
          },
          "options": {}
        },
        {
          "content": "go ${1:funcName}(${0})",
          "doc": "",
          "grammar": "snu",
          "label": "go someFunc(...)",
          "matches": {
            "go": true
          },
          "options": {}
        },
        {
          "content": "go func() {\n\t${1:${VISUAL}}\n}()\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "go func() { ... }()",
          "matches": {
            "gof": true
          },
          "options": {}
        },
        {
          "content": "func Test${1:Function}(t *testing.T) {\n\t${0:${VISUAL}}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "func TestXYZ(t *testing.T) { ... }",
          "matches": {
            "test": true
          },
          "options": {}
        },
        {
          "content": "t.Run(\"${0}\", func(t *testing.T){\n\n})",
          "doc": "",
          "grammar": "snu",
          "label": "t.Run(XYZ, func(t *testing.T){ ... })",
          "matches": {
            "tr": true
          },
          "options": {}
        },
        {
          "content": "var tests = []struct {\n\tname string\n\texpected string\n\tgiven string\n}{\n\t{\"${1}\", \"${2}\", \"${3}\",},\n}\nfor _, tt := range tests {\n\ttt := tt\n\tt.Run(tt.name, func(t *testing.T){\n\t\tactual := ${0:${VISUAL}}(tt.given)\n\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"$0(%s): expected %s, actual %s\", tt.given, tt.expected, actual)\n\t\t}\n\n\t})\n}",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "tt": true
          },
          "options": {}
        },
        {
          "content": "func ${1:handler}(w http.ResponseWriter, r *http.Request) {\n\t${0:fmt.Fprintf(w, \"hello world\")}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "http.HandlerFunc",
          "matches": {
            "hf": true
          },
          "options": {}
        },
        {
          "content": "${1:http}.HandleFunc(\"${2:/}\", func(w http.ResponseWriter, r *http.Request) {\n\t${0:fmt.Fprintf(w, \"hello world\")}\n})",
          "doc": "",
          "grammar": "snu",
          "label": "mux.HandleFunc",
          "matches": {
            "hhf": true
          },
          "options": {
            "!": true,
            "b": true
          }
        },
        {
          "content": "if err != nil {\n\tt.Errorf(\"${0:message}\")\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { t.Errorf(...) }",
          "matches": {
            "ter": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n\tt.Fatalf(\"${0:message}\")\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { t.Fatalf(...) }",
          "matches": {
            "terf": true
          },
          "options": {}
        },
        {
          "content": "func Example${1:Method}() {\n\t${0:${VISUAL}}\n\t// Output:\n}",
          "doc": "",
          "grammar": "snu",
          "label": "func ExampleXYZ() { ... }",
          "matches": {
            "example": true
          },
          "options": {}
        },
        {
          "content": "func Benchmark${1:Method}(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t${0:${VISUAL}}\n\t}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "func BenchmarkXYZ(b *testing.B) { ... }",
          "matches": {
            "benchmark": true
          },
          "options": {}
        },
        {
          "content": "var ${1:x} ${2:Type}${3: = ${0:value}}",
          "doc": "",
          "grammar": "snu",
          "label": "var x Type [= ...]",
          "matches": {
            "var": true
          },
          "options": {}
        },
        {
          "content": "var (\n\t${1:x} ${2:Type}${3: = ${0:value}}\n)",
          "doc": "",
          "grammar": "snu",
          "label": "var ( ... )",
          "matches": {
            "vars": true
          },
          "options": {}
        },
        {
          "content": "if !reflect.DeepEqual(${1:expected}, ${2:actual}) {\n\t_, file, line, _ := runtime.Caller(0)\n\tfmt.Printf(\"%s:%d:\\n\\n\\texp: %#v\\n\\n\\tgot: %#v\\n\\n\", filepath.Base(file), line, $1, $2)\n\tt.FailNow()\n}",
          "doc": "",
          "grammar": "snu",
          "label": "equals: test two identifiers with DeepEqual",
          "matches": {
            "eq": true
          },
          "options": {}
        }
      ]
    }
  ],
  "vim-go/gosnippets/snippets": [
    {
      "go": []
    },
    {
      "go": [
        {
          "content": "${1} := ${0}",
          "doc": "",
          "grammar": "snu",
          "label": "v := value",
          "matches": {
            ":": true
          },
          "options": {}
        },
        {
          "content": "${1:fn} := func() {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "fn := func() { ... }",
          "matches": {
            "anon": true
          },
          "options": {}
        },
        {
          "content": "append(${1:slice}, ${0:value})",
          "doc": "",
          "grammar": "snu",
          "label": "append(slice, value)",
          "matches": {
            "ap": true
          },
          "options": {}
        },
        {
          "content": "${1:slice} = append($1, ${0:value})",
          "doc": "",
          "grammar": "snu",
          "label": "slice = append(slice, value)",
          "matches": {
            "ap=": true
          },
          "options": {}
        },
        {
          "content": "break",
          "doc": "",
          "grammar": "snu",
          "label": "break",
          "matches": {
            "br": true
          },
          "options": {}
        },
        {
          "content": "chan ${0:int}",
          "doc": "",
          "grammar": "snu",
          "label": "chan Type",
          "matches": {
            "ch": true
          },
          "options": {}
        },
        {
          "content": "case ${1:value}:\n\t${0}",
          "doc": "",
          "grammar": "snu",
          "label": "case ...:",
          "matches": {
            "case": true
          },
          "options": {}
        },
        {
          "content": "const ${1:NAME} ${2:Type} = ${0:0}",
          "doc": "",
          "grammar": "snu",
          "label": "const XXX Type = ...",
          "matches": {
            "con": true
          },
          "options": {}
        },
        {
          "content": "const (\n\t${1:NAME} ${2:Type} = ${3:value}\n\t${0}\n)",
          "doc": "",
          "grammar": "snu",
          "label": "const ( ... )",
          "matches": {
            "cons": true
          },
          "options": {}
        },
        {
          "content": "const (\n\t${1:NAME} ${2:Type} = iota\n\t${0}\n)",
          "doc": "",
          "grammar": "snu",
          "label": "const ( ... = iota )",
          "matches": {
            "iota": true
          },
          "options": {}
        },
        {
          "content": "continue",
          "doc": "",
          "grammar": "snu",
          "label": "continue",
          "matches": {
            "cn": true
          },
          "options": {}
        },
        {
          "content": "default:\n\t${0}",
          "doc": "",
          "grammar": "snu",
          "label": "default: ...",
          "matches": {
            "default": true
          },
          "options": {}
        },
        {
          "content": "defer ${1:func}(${2})\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "defer someFunction()",
          "matches": {
            "df": true
          },
          "options": {}
        },
        {
          "content": "defer func() {\n\t${0}\n}()",
          "doc": "",
          "grammar": "snu",
          "label": "defer func() { ... }",
          "matches": {
            "def": true
          },
          "options": {}
        },
        {
          "content": "defer func() {\n\tif err := recover(); err != nil {\n\t\t${0}\n\t}\n}()",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "defr": true
          },
          "options": {}
        },
        {
          "content": "import (\n\t\"${1:package}\"\n)",
          "doc": "",
          "grammar": "snu",
          "label": "import ( ... )",
          "matches": {
            "import": true
          },
          "options": {}
        },
        {
          "content": "type ${1:Interface} interface {\n\t${2:/* TODO: add methods */}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "interface I { ... }",
          "matches": {
            "interface": true
          },
          "options": {}
        },
        {
          "content": "if ${1:condition} {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "else { ... }",
          "matches": {
            "if": true
          },
          "options": {}
        },
        {
          "content": "else {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "else": true
          },
          "options": {}
        },
        {
          "content": "if err := ${1:condition}; err != nil {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if err := ...; err != nil { ... }",
          "matches": {
            "ife": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n\treturn err\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { return err }",
          "matches": {
            "errn": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n\tt.Fatal(err)\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { t.Fatal(err) }",
          "matches": {
            "errt": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n\tlog.Fatal(err)\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { log.Fatal(err) }",
          "matches": {
            "errl": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n\treturn ${1:nil}, err\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { return [...], err }",
          "matches": {
            "errn,": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n\t${1}\n\treturn\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { ... return }",
          "matches": {
            "errh": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n\tpanic(${1})\n}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { panic(...) }",
          "matches": {
            "errp": true
          },
          "options": {}
        },
        {
          "content": "fallthrough",
          "doc": "",
          "grammar": "snu",
          "label": "fallthrough",
          "matches": {
            "ft": true
          },
          "options": {}
        },
        {
          "content": "for ${1} {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "for ... { ... }",
          "matches": {
            "for": true
          },
          "options": {}
        },
        {
          "content": "for ${1:i} := 0; $1 < ${2:N}; $1++ {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "for 0..N-1 { ... }",
          "matches": {
            "fori": true
          },
          "options": {}
        },
        {
          "content": "for ${2:k}, ${3:v} := range ${1} {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "for k, v := range items { ... }",
          "matches": {
            "forr": true
          },
          "options": {}
        },
        {
          "content": "func ${1:function}(${2}) ${3:error }{\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "func function(...) [error] { ... }",
          "matches": {
            "func": true
          },
          "options": {}
        },
        {
          "content": "fmt.Printf(\"${1} = %+v\\n\", $1)\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "fmt.Printf(...)",
          "matches": {
            "ff": true
          },
          "options": {}
        },
        {
          "content": "fmt.Println(\"${1}\")",
          "doc": "",
          "grammar": "snu",
          "label": "fmt.Println(...)",
          "matches": {
            "fn": true
          },
          "options": {}
        },
        {
          "content": "fmt.Errorf(\"${1}\")",
          "doc": "",
          "grammar": "snu",
          "label": "fmt.Errorf(...)",
          "matches": {
            "fe": true
          },
          "options": {}
        },
        {
          "content": "log.Printf(\"${1} = %+v\\n\", $1)",
          "doc": "",
          "grammar": "snu",
          "label": "log.Printf(...)",
          "matches": {
            "lf": true
          },
          "options": {}
        },
        {
          "content": "log.Println(\"${1}\")",
          "doc": "",
          "grammar": "snu",
          "label": "log.Println(...)",
          "matches": {
            "ln": true
          },
          "options": {}
        },
        {
          "content": "make(${1:[]string}, ${2:0})${0}",
          "doc": "",
          "grammar": "snu",
          "label": "make(Type, size)",
          "matches": {
            "make": true
          },
          "options": {}
        },
        {
          "content": "map[${1:string}]${0:int}",
          "doc": "",
          "grammar": "snu",
          "label": "map[Type]Type",
          "matches": {
            "map": true
          },
          "options": {}
        },
        {
          "content": "func main() {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "func main() { ... }",
          "matches": {
            "main": true
          },
          "options": {
            "head": true
          }
        },
        {
          "content": "func (${1:self} ${2:Type}) ${3:Do}(${4}) ${5:error }{\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "func (self Type) Method(...) [error] { ... }",
          "matches": {
            "meth": true
          },
          "options": {}
        },
        {
          "content": "if !ok {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if !ok { ... }",
          "matches": {
            "ok": true
          },
          "options": {}
        },
        {
          "content": "// Package $1 provides ${2:...}\npackage ${1:main}\n${0}",
          "doc": "",
          "grammar": "snu",
          "label": "package ...",
          "matches": {
            "package": true
          },
          "options": {}
        },
        {
          "content": "panic(\"${0}\")",
          "doc": "",
          "grammar": "snu",
          "label": "panic(\"...\")",
          "matches": {
            "panic": true,
            "pn": true
          },
          "options": {}
        },
        {
          "content": "return ${0}",
          "doc": "",
          "grammar": "snu",
          "label": "return ...",
          "matches": {
            "return": true,
            "rt": true
          },
          "options": {}
        },
        {
          "content": "select {\ncase ${1:v1} := <-${2:chan1}\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "select { case a := <-chan: ... }",
          "matches": {
            "select": true
          },
          "options": {}
        },
        {
          "content": "type ${1:Type} struct {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "type T struct { ... }",
          "matches": {
            "st": true
          },
          "options": {}
        },
        {
          "content": "switch ${1:var} {\ncase ${2:value1}:\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "switch x { ... }",
          "matches": {
            "switch": true
          },
          "options": {}
        },
        {
          "content": "fmt.Sprintf(\"%${1:s}\", ${2:var})",
          "doc": "",
          "grammar": "snu",
          "label": "fmt.Sprintf(...)",
          "matches": {
            "sp": true
          },
          "options": {}
        },
        {
          "content": "go ${1:funcName}(${0})",
          "doc": "",
          "grammar": "snu",
          "label": "go someFunc(...)",
          "matches": {
            "go": true
          },
          "options": {}
        },
        {
          "content": "go func(${1}) {\n\t${3:/* TODO */}\n}(${2})",
          "doc": "",
          "grammar": "snu",
          "label": "go func(...) { ... }(...)",
          "matches": {
            "gof": true
          },
          "options": {}
        },
        {
          "content": "func Test${1:Function}(t *testing.T) {\n\t${0}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "func TestXYZ(t *testing.T) { ... }",
          "matches": {
            "test": true
          },
          "options": {}
        },
        {
          "content": "t.Run(\"${0}\", func(t *testing.T){\n})",
          "doc": "",
          "grammar": "snu",
          "label": "t.Run(\"test name\", func(t *testing.T){ ... })",
          "matches": {
            "tr": true
          },
          "options": {}
        },
        {
          "content": "var tests = []struct {\n    name string\n    expected string\n    given string\n}{\n    {\"${2}\", \"${3}\", \"${4}\",},\n}\nfor _, tt := range tests {\n    tt := tt\n    t.Run(tt.name, func(t *testing.T){\n        actual := ${1:Function}(tt.given)\n        if actual != tt.expected {\n            t.Errorf(\"given(%s): expected %s, actual %s\", tt.given, tt.expected, actual)\n        }\n    })\n}",
          "doc": "",
          "grammar": "snu",
          "label": "var test = {...}{...} for {t.Run(){...}}",
          "matches": {
            "tt": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n  t.Errorf(\"${1}\")\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { t.Errorf(...) }",
          "matches": {
            "ter": true
          },
          "options": {}
        },
        {
          "content": "if err != nil {\n  t.Fatalf(\"${1}\")\n}",
          "doc": "",
          "grammar": "snu",
          "label": "if err != nil { t.Fatalf(...) }",
          "matches": {
            "terf": true
          },
          "options": {}
        },
        {
          "content": "func Example${1:Method}() {\n\t${0}\n\t// Output:\n}",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "example": true
          },
          "options": {}
        },
        {
          "content": "func Benchmark${1:Method}(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t${0}\n\t}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "benchmark": true
          },
          "options": {}
        },
        {
          "content": "if !reflect.DeepEqual(${1:expected}, ${2:actual}) {\n\t_, file, line, _ := runtime.Caller(0)\n\tfmt.Printf(\"%s:%d:\\n\\n\\texp: %#v\\n\\n\\tgot: %#v\\n\\n\", filepath.Base(file), line, $1, $2)\n\tt.FailNow()\n}",
          "doc": "",
          "grammar": "snu",
          "label": "equals: test two identifiers with DeepEqual",
          "matches": {
            "eq": true
          },
          "options": {}
        },
        {
          "content": "func ${1:handler}(w http.ResponseWriter, r *http.Request) {\n  ${0:fmt.Fprintf(w, \"hello world\")}\n}",
          "doc": "",
          "grammar": "snu",
          "label": "http.HandlerFunc",
          "matches": {
            "hf": true
          },
          "options": {}
        },
        {
          "content": "${1:http}.HandleFunc(\"${2:/}\", func(w http.ResponseWriter, r *http.Request) {\n  ${0:fmt.Fprintf(w, \"hello world\")}\n})",
          "doc": "",
          "grammar": "snu",
          "label": "mux.HandleFunc(...)",
          "matches": {
            "hhf": true
          },
          "options": {}
        }
      ]
    }
  ],
  "vim-snippets/UltiSnips": [
    {
      "xhtml": [
        "html"
      ]
    },
    {
      "xhtml": []
    }
  ],
  "vim-snippets/snippets": [
    {
      "chef": []
    },
    {
      "chef": [
        {
          "content": "# Cookbook File resource\ncookbook_file ${1:\"/path/to/file\"} do # The remote path where the file will reside\n\t${2:#}backup ${3} # How many backups of this file to keep. Set to false  if you want no backups\n\t${4:#}group ${5} # The group owner of the file (string or id)\n\t${6:#}mode ${7} # The octal mode of the file - e.g. 0755\n\t${8:#}owner ${9} # The owner for the file\n\t${10:#}source ${11} # The basename of the source file\n\t${12:#}cookbook ${13} # The cookbook this file is stored in\n\t${14:#}${15: action :create} # Create this file (Default)\n\t${16:#}${17: action :create_if_missing} # Create only if it doesn't exist yet\n\t${18:#}${0: action :delete} # Delete this file\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "cookbook_file": true
          },
          "options": {}
        },
        {
          "content": "# Execute resource\nexecute ${1:\"command to execute\"} do # The command to execute\n\t${2:#}creates ${3:nil} # A file this command creates - if the file exists, the command will not be run.\n\t${4:#}cwd ${5:nil} # Current working directory to run the command from.\n\t${6:#}environment ${7:nil} # A hash of environment variables to set before running this command.\n\t${8:#}group ${9:nil} # A group name or group ID that we should change to before running this command.\n\t${10:#}path ${11:nil} # An array of paths to use when searching for the command. Nil uses system path.\n\t${12:#}returns ${13:0} # The return value of the command - this resource raises an exception if the return value does not match.\n\t${14:#}timeout ${15:nil} # How many seconds to let the command run before timing it out.\n\t${16:#}user ${17:nil} # A user name or user ID that we should change to before running this command.\n\t${18:#}umask ${19:nil} # Umask for files created by the command\n\t${20:#}${21:action :run} # Run this command (Default)\n\t${22:#}${0:action :nothing} # Do not run this command\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "execute": true
          },
          "options": {}
        },
        {
          "content": "# Link resource\nlink ${1:\"/target/file\"} do # The file name of the link\n\t${2:#}to ${3} # The real file you want to link to\n\t${4:#}link_type ${5:symbolic} # Either :symbolic or :hard\n\t${6:#}owner ${7} # The owner of the symlink\n\t${8:#}group ${9} # The group of the symlink\n\t${10:#}${11:action :create} # Create a link (Default)\n\t${12:#}${0:action :delete} # Delete a link\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "link": true
          },
          "options": {}
        },
        {
          "content": "# Package resource\npackage ${1:\"package_name\"} do # Name of the package to install\n\t${2:#}version ${3:nil} # The version of the package to install/upgrade\n\t${4:#}response_file ${5:nil} # An optional response file - used to pre-seed packages (note: the file is fetched by Remote File)\n\t${6:#}source ${7} # Used to provide an optional package source for providers that use a local file (rubygems, dpkg and rpm)\n\t${8:#}options ${9:nil} # Add additional options to the underlying package command\n\t${10:#}gem_binary ${11:gem} # A gem_package attribut to specify a gem binary. Useful for installing ruby 1.9 gems while running chef in ruby 1.8\n\t${12:#}${13:action :install} # Install a package - if version is provided, install that specific version (Default)\n\t${14:#}${15:action :upgrade} # Upgrade a package - if version is provided, upgrade to that specific version\n\t${16:#}${17:action :remove} # Remove a package\n\t${18:#}${0:action :purge} # Purge a package (this usually entails removing configuration files as well as the package itself)\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "package": true
          },
          "options": {}
        },
        {
          "content": "# Service resource\nservice ${1:\"service_name\"} do # Name of the service\n\t${2:#}enabled ${3:nil} # Whether the service is enabled at boot time\n\t${4:#}running ${5:nil} # Make sure the service is running. Start if stopped\n\t${6:#}pattern ${7} # Pattern to look for in the process table\n\t${8:#}start_command ${9:nil} # Command used to start this service\n\t${10:#}stop_command ${11:nil} # Command used to stop this service\n\t${12:#}status_command ${13:nil} # Command used to check the service run status\n\t${14:#}restart_command ${15:nil} # Command used to restart this service\n\t${16:#}reload_command ${17:nil} # Command used to tell this service to reload its configuration\n\t${18:#}supports ${19:false} # Features this service supports, ie :restart, :reload, :status\n\t${20:#}${21:action :enable} # Enable this service\n\t${22:#}${23:action :disable} # Disable this service\n\t${24:#}${25:action :nothing} # Don't do anything with this service (Default)\n\t${26:#}${27:action :start} # Start this service\n\t${28:#}${29:action :stop} # Stop this service\n\t${30:#}${31:action :restart} # Restart this service\n\t${32:#}${0:action :reload} # Reload the configuration for this service\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "service": true
          },
          "options": {}
        },
        {
          "content": "# File resource\nfile ${1:\"/path/to/file\"} do # Path to the file\n\t${2:#}backup ${3:5} # How many backups of this file to keep. Set to false if you want no backups.\n\t${4:#}owner ${5} # The owner for the file\n\t${6:#}group ${7} # The group owner of the file (string or id)\n\t${8:#}mode ${9} # The octal mode of the file (4-digit format)\n\t${10:#}content ${11:nil} # A string to write to the file. This will replace any previous content if set\n\t${12:#}${13:action :create} # Create this file (Default)\n\t${14:#}${15:action :delete} # Delete this file\n\t${16:#}${0:action :touch} # Touch this file (update the mtime/atime)\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "file": true
          },
          "options": {}
        },
        {
          "content": "# Directory resource\ndirectory ${1:\"/path/to/dir\"} do # The path to the directory\n\t${2:#}group ${3} # The group owner of the directory (string or id)\n\t${4:#}mode ${5} # The octal mode of the directory, eg 0755\n\t${6:#}owner ${7} # The owner for the directory\n\t${10:#}recursive ${11:false} # When deleting the directory, delete it recursively. When creating the directory, create recursively (ie, mkdir -p)\n\t${12:#}${13:action :create} # Create this directory (Default)\n\t${14:#}${0:action :delete} # Delete this directory\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "directory": true
          },
          "options": {}
        },
        {
          "content": "# Template resource\ntemplate ${1:\"/path/to/file\"} do # Path to the file\n\t${2:#}cookbook ${3:nil} # Specify the cookbook where the template is located, default is current cookbook\n\t${4:#}source ${5:nil} # Template source file. Found in templates/default for the cookbook\n\t${6:#}variables ${7} # Variables to use in the template\n\t${8:#}local ${9:false} # Is the template already present on the node?\n\t${10:#}backup ${11:5} # How many backups of this file to keep. Set to false if you want no backups.\n\t${12:#}owner ${13} # The owner for the file\n\t${14:#}group ${15} # The group owner of the file (string or id)\n\t${16:#}mode ${17} # The octal mode of the file (4-digit format)\n\t${18:#}content ${19:nil} # A string to write to the file. This will replace any previous content if set\n\t${20:#}${21:action :create} # Create the file (Default)\n\t${22:#}${23:action :delete} # Delete this file\n\t${24:#}${0:action :touch} # Touch this file (update the mtime/atime)\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "template": true
          },
          "options": {}
        },
        {
          "content": "# SCM Resource, Chef::Provider::Subversion\nsvn ${1:\"/destination/path\"} do # Path to clone/checkout/export the source to\n\t${2:#}repository ${3} # URI of the repository\n\t${4:#}revision ${5:\"HEAD\"} # revision to checkout. can be symbolic, like \"HEAD\" or an SCM specific revision id\n\t${6:#}reference ${7} # (Git only) alias for revision\n\t${8:#}user ${9:nil} # System user to own the checked out code\n\t${10:#}group ${11:nil} # System group to own the checked out code\n\t${12:#}svn_username ${13} # (Subversion only) Username for Subversion operations\n\t${14:#}svn_password ${15} # (Subversion only) Password for Subversion operations\n\t${16:#}svn_arguments ${17} # (Subversion only) Extra arguments passed to the subversion command\n\t${18:#}${19:action :sync} # Update the source to the specified revision, or get a new checkout (Default)\n\t${20:#}${21:action :checkout} # Checkout the source. Does nothing if a checkout is available\n\t${22:#}${0:action :export} # Export the source, excluding or removing any version control artifacts\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "svn": true
          },
          "options": {}
        },
        {
          "content": "# SCM Resource, Chef::Provider::Git\ngit ${1:\"/destination/path\"} do # Path to clone/checkout/export the source to\n\t${2:#}repository ${3} # URI of the repository\n\t${4:#}revision ${5:\"HEAD\"} # revision to checkout. can be symbolic, like \"HEAD\" or an SCM specific revision id\n\t${6:#}reference ${7} # (Git only) alias for revision\n\t${8:#}user ${9:nil} # System user to own the checked out code\n\t${10:#}group ${11:nil} # System group to own the checked out code\n\t${12:#}depth ${13:nil} # (Git only) Number of past revisions to include in Git shallow clone\n\t${14:#}enable_submodules ${15:\"false\"} # (Git only) performs a submodule init and submodule update\n\t${16:#}remote ${17:\"origin\"} # (Git only) remote repository to use for syncing an existing clone\n\t${18:#}ssh_wrapper ${19} # (Git only) path to a wrapper script for running SSH with git. GIT_SSH environment variable is set to this.\n\t${20:#}${21:action :sync} # Update the source to the specified revision, or get a new clone (Default)\n\t${22:#}${23:action :checkout} # Clone the source. Does nothing if a checkout is available\n\t${24:#}${0:action :export} # Export the source, excluding or removing any version control artifacts\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "git": true
          },
          "options": {}
        },
        {
          "content": "# Deploy resource\ndeploy ${1:\"/deploy/dir/\"} do # Path to deploy to\n\t${2:#}deploy_to ${3} # The \"meta root\" for your application.\n\t${4:#}repository ${5} # URI of the repository\n\t${6:#}repo ${7} # alias for repository\n\t${8:#}revision ${9:\"HEAD\"} # revision to checkout. can be symbolic, like \"HEAD\" or an SCM specific revision id\n\t${10:#}branch ${11} # alias for revision\n\t${12:#}user ${13:nil} # System user to run the deploy as\n\t${14:#}group ${15:nil} # System group to run the deploy as\n\t${16:#}svn_username ${17} # (Subversion only) Username for Subversion operations}\n\t${18:#}svn_password ${19} # (Subversion only) Password for Subversion operations}\n\t${20:#}svn_arguments ${21} # (Subversion only) Extra arguments passed to the subversion command}\n\t${22:#}shallow_clone ${23:nil} # (Git only) boolean, true sets clone depth to 5\n\t${24:#}enable_submodules ${25:false} # (Git only) performs a submodule init and submodule update\n\t${26:#}remote ${27:\"origin\"} # (Git only) remote repository to use for syncing an existing clone\n\t${28:#}ssh_wrapper ${29} # (Git only) path to a wrapper script for running SSH with git. GIT_SSH environment variable is set to this.\n\t${30:#}git_ssh_wrapper ${31} # alias for ssh_wrapper\n\t${32:#}scm_provider ${33:Chef::Provider::Git} # SCM Provider to use.\n\t${34:#}repository_cache ${35: \"cached-copy\"} # Name of the subdirectory where the pristine copy of your app's source is kept\n\t${36:#}environment ${37} # A hash of the form {\"ENV_VARIABLE\"=>\"VALUE\"}}\n\t${38:#}purge_before_symlink ${39:%w(log tmp/pids public/system)} # An array of paths, relative to app root, to be removed from a checkout before symlinking\n\t${40:#}create_dirs_before_symlink ${41:%w(tmp public config)} # Directories to create before symlinking. Runs after purge_before_symlink\n\t${42:#}symlinks ${43:\"system\" => \"public/system\", \"pids\" => \"tmp/pids\", \"log\" => \"log\"} # A hash that maps files in the shared directory to their paths in the current release\n\t${44:#}symlink_before_migrate ${45:\"config/database.yml\" => \"config/database.yml\"} # A hash that maps files in the shared directory into the current release. Runs before migration\n\t${46:#}migrate ${47:false} # Should the migration command be executed? (true or false)\n\t${48:#}migration_command ${49} # A string containing a shell command to execute to run the migration\n\t${50:#}restart_command ${51:nil} # A code block to evaluate or a string containing a shell command\n\t${52:#}before_migrate ${53:\"deploy/before_migrate.rb\"} # A block or path to a file containing chef code to run before migrating\n\t${54:#}before_symlink ${55:\"deploy/before_symlink.rb\"} # A block or path to a file containing chef code to run before symlinking\n\t${56:#}before_restart ${57:\"deploy/before_restart.rb\"} # A block or path to a file containing chef code to run before restarting\n\t${58:#}after_restart ${59:\"deploy/after_restart.rb\"} # A block or path to a file containing chef code to run after restarting\n\t${60:#}${61::deploy} # Deploy the application (Default)\n\t${62:#}${63::force_deploy} # For the revision deploy strategy, this removes any existing release of the same code version and re-deploys in its place\n\t${64:#}${0::rollback} # Rollback the application to the previous release\nend",
          "doc": "",
          "grammar": "snu",
          "label": "",
          "matches": {
            "deploy": true
          },
          "options": {}
        }
      ]
    }
  ],
  "vscode-R/snippets": [
    {
      "r-snippets": []
    },
    {
      "r-snippets": [
        {
          "content": "rug(${1:jitter(${2:x})})",
          "doc": "",
          "grammar": "lsp",
          "label": "rug",
          "matches": {
            "rug": true
          },
          "options": {}
        },
        {
          "content": "apply(${1:X}, ${2:MARGIN}, ${3:FUN}, ${4:...})",
          "doc": "Apply",
          "grammar": "lsp",
          "label": "app",
          "matches": {
            "apply": true
          },
          "options": {}
        },
        {
          "content": "attach(${1:frame})",
          "doc": "Attach",
          "grammar": "lsp",
          "label": "att",
          "matches": {
            "attach": true
          },
          "options": {}
        },
        {
          "content": "cat(${1:file}, ${2:sep = ${3:\"\"}}, ${4:fill = ${5:FALSE}}, ${6:labels = ${7:NULL}}, ${8:append = ${9:FALSE}})",
          "doc": "Cat",
          "grammar": "lsp",
          "label": "cat",
          "matches": {
            "cat": true
          },
          "options": {}
        },
        {
          "content": "cum${1:max}(${2:x})",
          "doc": "Cummulative",
          "grammar": "lsp",
          "label": "cum",
          "matches": {
            "cum": true
          },
          "options": {}
        },
        {
          "content": "cummax(${1:x}",
          "doc": "Cummulative max",
          "grammar": "lsp",
          "label": "cuma",
          "matches": {
            "cumaax": true
          },
          "options": {}
        },
        {
          "content": "cummin(${1:x}",
          "doc": "Cummulative min",
          "grammar": "lsp",
          "label": "cumi",
          "matches": {
            "cumin": true
          },
          "options": {}
        },
        {
          "content": "data.frame(${1:...}, ${2:row.names = ${3:NULL}}, ${4:check.rows = ${5:FALSE}}, ${6:check.names = ${7:TRUE}}, ${8:stringsAsFactors = ${9:default.stringsAsFactors()}})",
          "doc": "Data Frame",
          "grammar": "lsp",
          "label": "daf",
          "matches": {
            "data.frame": true
          },
          "options": {}
        },
        {
          "content": "density(${1:x}${2:, bw = ${3:bandwidth}})",
          "doc": "Density",
          "grammar": "lsp",
          "label": "den",
          "matches": {
            "density": true
          },
          "options": {}
        },
        {
          "content": "detach(${0:})",
          "doc": "Detach",
          "grammar": "lsp",
          "label": "det",
          "matches": {
            "detach": true
          },
          "options": {}
        },
        {
          "content": "cut(${1:x}, breaks = c(${2:${3:}, ${4:max(${1:x})}}))",
          "doc": "Divide Into Intervals",
          "grammar": "lsp",
          "label": "cut",
          "matches": {
            "cut": true
          },
          "options": {}
        },
        {
          "content": "expand.grid(${1:...}, ${2:KEEP.OUT.ATTRS = ${3:TRUE}}, ${4:stringsAsFactors = ${5:TRUE}})",
          "doc": "Expand grid",
          "grammar": "lsp",
          "label": "exp",
          "matches": {
            "exppand": true
          },
          "options": {}
        },
        {
          "content": "factor(${1:x})",
          "doc": "Factor",
          "grammar": "lsp",
          "label": "fac",
          "matches": {
            "factor": true
          },
          "options": {}
        },
        {
          "content": "function(${1:x}) ${3:{$0\\}}",
          "doc": "Function",
          "grammar": "lsp",
          "label": "fun",
          "matches": {
            "function": true
          },
          "options": {}
        },
        {
          "content": "glm(${1:formula}, ${2:family = {3:gaussian}}, ${4:data})",
          "doc": "Generalized Linear Models",
          "grammar": "lsp",
          "label": "glm",
          "matches": {
            "glm": true
          },
          "options": {}
        },
        {
          "content": "grep(${1:pattern}, ${2:x}, ${3:ignore.case = ${4:FALSE}}, ${5:perl = ${6:FALSE}})",
          "doc": "Grep",
          "grammar": "lsp",
          "label": "grep",
          "matches": {
            "grep": true
          },
          "options": {}
        },
        {
          "content": "grep(${1:pattern}, ${2:x}, ${3:ignore.case = ${4:FALSE}}, ${5:perl = ${6:FALSE}}, ${7:value = ${8:FALSE}}, ${9:fixed = ${10:TRUE}})",
          "doc": "Grep",
          "grammar": "lsp",
          "label": "grep2",
          "matches": {
            "grep": true
          },
          "options": {}
        },
        {
          "content": "grep(${1:pattern}, ${2:x}, ${3:ignore.case = ${4:FALSE}}, ${5:perl = ${6:FALSE}}, ${7:fixed = ${8:TRUE}})",
          "doc": "Grep logical",
          "grammar": "lsp",
          "label": "grepl",
          "matches": {
            "grepl": true
          },
          "options": {}
        },
        {
          "content": "install.packages(${1:pkgs}, ${2:lib}, ${3:repos = ${4:getOption(\"repos\")}}, ${5:contriburl = ${6:contrib.url(repos, type)}})",
          "doc": "Install package",
          "grammar": "lsp",
          "label": "ins",
          "matches": {
            "insall": true
          },
          "options": {}
        },
        {
          "content": "kmeans(${1:x}, ${2:centers}, ${3:iter.max = ${4:10}}, ${5:nstart = ${6:1}}, ${7:algorithm = ${8:c(\"Hartigan-Wong\", \"Lloyd\", \"Forgy\",\"MacQueen\")}}, ${9:trace = ${10:FALSE}})",
          "doc": "Kmeans",
          "grammar": "lsp",
          "label": "km",
          "matches": {
            "kmeans": true
          },
          "options": {}
        },
        {
          "content": "kruskal.test(${1:formula}, ${2:data}, ${3:subset}, ${4:na.action}, ${5:...})",
          "doc": "Kruskal-Wallis Rank Sum test",
          "grammar": "lsp",
          "label": "kr",
          "matches": {
            "kruskal": true
          },
          "options": {}
        },
        {
          "content": "lapply(${1:X}, ${2:FUN}, ${3:...})",
          "doc": "Lapply",
          "grammar": "lsp",
          "label": "lap",
          "matches": {
            "lapply": true
          },
          "options": {}
        },
        {
          "content": "length(${1:x})",
          "doc": "Length",
          "grammar": "lsp",
          "label": "len",
          "matches": {
            "length": true
          },
          "options": {}
        },
        {
          "content": "library(${1:package}, ${2:help}, ${3:pos = ${4:2}}, ${5:lib.loc = ${6:NULL}})",
          "doc": "Library",
          "grammar": "lsp",
          "label": "lib",
          "matches": {
            "library": true
          },
          "options": {}
        },
        {
          "content": "lines(${1:x}${2:, color=${3:red}})",
          "doc": "Polygonal Line",
          "grammar": "lsp",
          "label": "lin",
          "matches": {
            "lines": true
          },
          "options": {}
        },
        {
          "content": "data(${1:name})",
          "doc": "Load Dataset",
          "grammar": "lsp",
          "label": "dat",
          "matches": {
            "data": true
          },
          "options": {}
        },
        {
          "content": "load(${1:file}, ${2:envir = ${3:parent.frame()}}, ${4:verbose = ${5:FALSE}})",
          "doc": "Load RData",
          "grammar": "lsp",
          "label": "loa",
          "matches": {
            "load": true
          },
          "options": {}
        },
        {
          "content": "mean(${1:x}${2:, na.rm=${3:FALSE}})",
          "doc": "Mean",
          "grammar": "lsp",
          "label": "mea",
          "matches": {
            "mean": true
          },
          "options": {}
        },
        {
          "content": "merge(${1:x}, ${2:y}, ${3:by = ${4:intersect(names(x), names(y))}}, ${5:all = ${6:FALSE}})",
          "doc": "Merge",
          "grammar": "lsp",
          "label": "mer",
          "matches": {
            "merge": true
          },
          "options": {}
        },
        {
          "content": "names(${1:x})",
          "doc": "Names",
          "grammar": "lsp",
          "label": "nam",
          "matches": {
            "names": true
          },
          "options": {}
        },
        {
          "content": "options(${1:...})",
          "doc": "Options",
          "grammar": "lsp",
          "label": "opt",
          "matches": {
            "option": true
          },
          "options": {}
        },
        {
          "content": "order(${1:...}, ${2:na.last = ${3:TRUE}}, ${4:decreasing = ${5:FALSE}})",
          "doc": "Order",
          "grammar": "lsp",
          "label": "ord",
          "matches": {
            "order": true
          },
          "options": {}
        },
        {
          "content": "outer(${1:X}, ${2:Y}, ${3:FUN = ${4:\"*\"}}, ${5:...})",
          "doc": "Outer",
          "grammar": "lsp",
          "label": "out",
          "matches": {
            "outer": true
          },
          "options": {}
        },
        {
          "content": "paste(${1:...}, ${2:sep = ${3:\" \"}}, ${3:collapse = ${4:NULL}})",
          "doc": "Paste",
          "grammar": "lsp",
          "label": "pas",
          "matches": {
            "paste": true
          },
          "options": {}
        },
        {
          "content": "paste(${1:...}, ${2:collapse = ${3:NULL}})",
          "doc": "Paste0",
          "grammar": "lsp",
          "label": "pas0",
          "matches": {
            "pas0": true
          },
          "options": {}
        },
        {
          "content": "plot(${1:x}, ${2:y}, ${3:...})",
          "doc": "Plot",
          "grammar": "lsp",
          "label": "plot",
          "matches": {
            "plot": true
          },
          "options": {}
        },
        {
          "content": "points(${1:x}, ${2:y = ${3:NULL}}, ${4:type = ${5:\"p\"}}, ${6:...})",
          "doc": "Points",
          "grammar": "lsp",
          "label": "poi",
          "matches": {
            "point": true
          },
          "options": {}
        },
        {
          "content": "print(${1:x}, ${2:...})",
          "doc": "Print",
          "grammar": "lsp",
          "label": "pri",
          "matches": {
            "print": true
          },
          "options": {}
        },
        {
          "content": "quantile(${1:x}, ${2:probs = ${3:seq(0, 1, 0.25)}}, ${4:na.rm = ${5:FALSE}}, ${6:names = ${7:TRUE}}, ${8:type = ${9:7}}, ${10:...})",
          "doc": "Quantile",
          "grammar": "lsp",
          "label": "qua",
          "matches": {
            "quantile": true
          },
          "options": {}
        },
        {
          "content": "read.table('${1:filename}'${2:, header = ${3:TRUE},  sep = '${4:\t}',  stringsAsFactors = ${5:FALSE}})",
          "doc": "Read From File",
          "grammar": "lsp",
          "label": "reat",
          "matches": {
            "read": true
          },
          "options": {}
        },
        {
          "content": "rep(${1:x}, ${2:...})",
          "doc": "Rep",
          "grammar": "lsp",
          "label": "rep",
          "matches": {
            "rep": true
          },
          "options": {}
        },
        {
          "content": "sample(${1:x}, ${2:size}, ${3:replace = ${4:FALSE}}, ${5:prob = ${6:NULL}})",
          "doc": "Sample",
          "grammar": "lsp",
          "label": "sam",
          "matches": {
            "sample": true
          },
          "options": {}
        },
        {
          "content": "seq(${1:from}, ${2:to}, ${3:by})",
          "doc": "Sequence (from,to,by)",
          "grammar": "lsp",
          "label": "seq",
          "matches": {
            "seq": true
          },
          "options": {}
        },
        {
          "content": "sort(${1:x})",
          "doc": "Sort",
          "grammar": "lsp",
          "label": "sor",
          "matches": {
            "sort": true
          },
          "options": {}
        },
        {
          "content": "source(${1:'${2:}'}${3:, chdir = ${4:TRUE}})",
          "doc": "Source",
          "grammar": "lsp",
          "label": "sou",
          "matches": {
            "source": true
          },
          "options": {}
        },
        {
          "content": "sd(${1:x}${2:, na.rm=${3:FALSE}})",
          "doc": "Standard deviation",
          "grammar": "lsp",
          "label": "sd",
          "matches": {
            "sd": true
          },
          "options": {}
        },
        {
          "content": "table(${1:...})",
          "doc": "Table",
          "grammar": "lsp",
          "label": "tab",
          "matches": {
            "table": true
          },
          "options": {}
        },
        {
          "content": "tapply(${1:X}, ${2:INDEX}, ${3:FUN = ${4:NULL}}, ${5:...}, ${6:simplify = ${7:TRUE}})",
          "doc": "Tapply",
          "grammar": "lsp",
          "label": "tap",
          "matches": {
            "tapply": true
          },
          "options": {}
        },
        {
          "content": "unique(${1:x}, ${2:incomparables = ${3:FALSE}}, ${4:...})",
          "doc": "Unique",
          "grammar": "lsp",
          "label": "uni",
          "matches": {
            "unique": true
          },
          "options": {}
        },
        {
          "content": "which(${1:x}, ${2:arr.ind = ${3:FALSE}}, ${4:useNames = ${5:TRUE}})",
          "doc": "Which",
          "grammar": "lsp",
          "label": "whi",
          "matches": {
            "which": true
          },
          "options": {}
        },
        {
          "content": "write.csv(${1:x}, ${2:file = ${3:\"\"}}, ${4:append = ${5:FALSE}}, ${6:quote = ${7:TRUE}}, ${8:sep = ${9:\" \"}}",
          "doc": "Write csv",
          "grammar": "lsp",
          "label": "wric",
          "matches": {
            "write": true
          },
          "options": {}
        },
        {
          "content": "${1:file = }file.choose()${0:}",
          "doc": "file.choose",
          "grammar": "lsp",
          "label": "fch",
          "matches": {
            "fch": true
          },
          "options": {}
        },
        {
          "content": "library(cluster)\nclara(${1:xData}, k = ${2:k}, metric = ${3:metric}, stand = ${4:stand}, samples = ${5:samples})",
          "doc": "Cluster data into k clusters (library: cluster)",
          "grammar": "lsp",
          "label": "Clustering",
          "matches": {
            "clara": true
          },
          "options": {}
        },
        {
          "content": "lmObj <- lm(${1:yCol} ~ {2:xCol}, data = ${3:data}, subset = ${4:subset}, weights = ${5:weights}, na.action = ${6:na.action})\nsummary(lmObj)",
          "doc": "Fit a linear model",
          "grammar": "lsp",
          "label": "Linear model",
          "matches": {
            "lm": true
          },
          "options": {}
        },
        {
          "content": "lmObj <- lm(${1:yCol} ~ {2:xCol}, data = ${3:data}, subset = ${4:subset}, weights = ${5:weights}, na.action = ${6:na.action})\nsummary(lmObj)\nplot(lmObj, which=c(1)) # Plot residuals versus fitted",
          "doc": "Fit a linear model and create a plot",
          "grammar": "lsp",
          "label": "Linear model with plot",
          "matches": {
            "lmplot": true
          },
          "options": {}
        },
        {
          "content": "loess(${1:yCol} ~ {2:xCol}, data = ${3:data}, subset = ${4:subset}, weights = ${5:weights}, span = ${6:span},\ndegree = ${7:degree}, na.action = {8:na.action})",
          "doc": "Local polynomial regression",
          "grammar": "lsp",
          "label": "loess",
          "matches": {
            "loess": true
          },
          "options": {}
        },
        {
          "content": "summary(${1:dataName}, digits = ${2:digits}, maxsum = ${3:maxsum})",
          "doc": "Mean, median, 25th and 75th quartiles, min, and max of variables",
          "grammar": "lsp",
          "label": "Descriptive statistics summary",
          "matches": {
            "summary": true
          },
          "options": {}
        },
        {
          "content": "crossTable <- xtabs(~${1:varNames}, data= ${2:dataName}, exclude = c(${3:exclude}), subset = ${4:subset})\nftable(crossTable)  # print crosstabs\nsummary(crossTable) # chi-square tests",
          "doc": "Crosstabulations for variables in a data frame",
          "grammar": "lsp",
          "label": "Crosstabs",
          "matches": {
            "xtabs": true
          },
          "options": {}
        },
        {
          "content": "${1:dfname} <- data.frame(${2:a} = character(), ${3:b} = character())",
          "doc": "Code snippet for an empty character data frame",
          "grammar": "lsp",
          "label": "Empty data frame (character)",
          "matches": {
            "df2c": true
          },
          "options": {}
        },
        {
          "content": "${1:dfname} <- data.frame(${2:x} = numeric(), ${3:y} = numeric())",
          "doc": "Code snippet for an empty numerical data frame",
          "grammar": "lsp",
          "label": "Empty data frame (numeric)",
          "matches": {
            "df2n": true
          },
          "options": {}
        },
        {
          "content": "${1:dfname} <- data.frame(${2:varlist})",
          "doc": "Create a data frame from vectors",
          "grammar": "lsp",
          "label": "Data frame",
          "matches": {
            "dfv": true
          },
          "options": {}
        },
        {
          "content": "${1:outFactor} <- factor(x = ${2:dataVec}, levels = ${3:levels}, exclude = ${4:exclude})",
          "doc": "Create a factor (categorical variable) from a vector",
          "grammar": "lsp",
          "label": "Categorical variable",
          "matches": {
            "factor": true
          },
          "options": {}
        },
        {
          "content": "${1:outMatrix} <- matrix(data = ${2:dataVec}, nrow = ${3:nrow}, ncol = ${4:ncol}, byrow = ${5:byrow})",
          "doc": "Create a matrix from a vector",
          "grammar": "lsp",
          "label": "Matrix",
          "matches": {
            "matrix": true
          },
          "options": {}
        },
        {
          "content": "${1:newdataframe} <- na.omit(${2:dataframe})",
          "doc": "Remove all rows with missing values from data frame",
          "grammar": "lsp",
          "label": "remove missings",
          "matches": {
            "naomit": true
          },
          "options": {}
        },
        {
          "content": "${1:dfname} <- read.csv(file = \"${2:file}\", header = ${3|TRUE,FALSE|},  sep = \"${4|\\,,;|}\", row.names = ${5:NULL},  stringsAsFactors = ${6|FALSE,TRUE|})",
          "doc": "Read a data table from a comma-separated file (CSV) and create a data frame",
          "grammar": "lsp",
          "label": "Read CSV",
          "matches": {
            "readc": true
          },
          "options": {}
        },
        {
          "content": "else {\n   ${1:selected}\n}",
          "doc": "Code snippet for 'else' conditional",
          "grammar": "lsp",
          "label": "else",
          "matches": {
            "else": true
          },
          "options": {}
        },
        {
          "content": "else if (${1:condition}) {\n   ${2:selected}\n}",
          "doc": "Code snippet for 'else' conditional",
          "grammar": "lsp",
          "label": "elseif",
          "matches": {
            "elseif": true
          },
          "options": {}
        },
        {
          "content": "for (${1:identifier} in ${2:collection}) {\n   ${3:selected}\n}",
          "doc": "Code snippet for 'for' loop",
          "grammar": "lsp",
          "label": "for",
          "matches": {
            "for": true
          },
          "options": {}
        },
        {
          "content": "${1:name} <- function(${2:parameters}) {\n   ${3:selected}\n}",
          "doc": "Named function",
          "grammar": "lsp",
          "label": "function",
          "matches": {
            "function": true
          },
          "options": {}
        },
        {
          "content": "if (${1:condition}) {\n   ${2:selected}\n}",
          "doc": "Code snippet for 'if' conditional",
          "grammar": "lsp",
          "label": "if",
          "matches": {
            "if": true
          },
          "options": {}
        },
        {
          "content": "if (${1:condition}) {\n   ${2:selected}\n} else {\n   \n}",
          "doc": "Code snippet for 'if-else' conditional block",
          "grammar": "lsp",
          "label": "if-else block",
          "matches": {
            "ifelse": true
          },
          "options": {}
        },
        {
          "content": "#region $0",
          "doc": "Folding Region Start",
          "grammar": "lsp",
          "label": "Region Start",
          "matches": {
            "#region": true
          },
          "options": {}
        },
        {
          "content": "#endregion",
          "doc": "Folding Region End",
          "grammar": "lsp",
          "label": "Region End",
          "matches": {
            "#endregion": true
          },
          "options": {}
        }
      ]
    }
  ],
  "vscode-angular-snippets/snippets": [
    {
      "typescript": []
    },
    {
      "typescript": [
        {
          "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplateUrl: '${2:name}.component.html'\n})\n\nexport class ${3:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }$0\n}",
          "doc": "Angular component",
          "grammar": "lsp",
          "label": "Angular Component",
          "matches": {
            "a-component": true
          },
          "options": {}
        },
        {
          "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplate: `$0`\n})\n\nexport class ${2:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }\n}",
          "doc": "Angular component with an inline template",
          "grammar": "lsp",
          "label": "Angular Component with Inline Template",
          "matches": {
            "a-component-inline": true
          },
          "options": {}
        },
        {
          "content": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n\tname: '${1:selector-name}'\n})\n\nexport class ${2:Name}Pipe implements PipeTransform {\n\ttransform(value: any, ...args: any[]): any {\n\t\t$0\n\t}\n}",
          "doc": "Angular pipe",
          "grammar": "lsp",
          "label": "Angular Pipe",
          "matches": {
            "a-pipe": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor() { }\n\t$0\n}",
          "doc": "Angular Service with Injectable ProvidedIn Root",
          "grammar": "lsp",
          "label": "Angular Service",
          "matches": {
            "a-service": true
          },
          "options": {}
        },
        {
          "content": "{ path: '', pathMatch: 'full', redirectTo: '${1:path}' },$0",
          "doc": "Angular default route path",
          "grammar": "lsp",
          "label": "Angular Default Route Path",
          "matches": {
            "a-route-path-default": true
          },
          "options": {}
        },
        {
          "content": "{\n\tpath: '${1:path}', \n\tcomponent: ${2:Component},\n\tchildren: [\n\t\t{ path: '${3:childpath}', component: ${4:ChildComponent} }\n\t]\n},$0",
          "doc": "Angular route path with children",
          "grammar": "lsp",
          "label": "Angular Route Path with Children",
          "matches": {
            "a-route-path-with-children": true
          },
          "options": {}
        },
        {
          "content": "{ path: '**', component: ${1:PathNotFoundComponent} },$0",
          "doc": "Angular 404 route path",
          "grammar": "lsp",
          "label": "Angular 404 Route Path",
          "matches": {
            "a-route-path-404": true
          },
          "options": {}
        },
        {
          "content": "{ path: '${1:path}', component: ${2:Name}Component },$0",
          "doc": "Angular eager route path",
          "grammar": "lsp",
          "label": "Angular Eager Route Path",
          "matches": {
            "a-route-path-eager": true
          },
          "options": {}
        },
        {
          "content": "{\n\tpath: '${1:path}', \n\tloadChildren: () => import('${2:lazy-path}').then(m => m.${3:lazy-module})\n},$0",
          "doc": "Angular lazy route path",
          "grammar": "lsp",
          "label": "Angular Lazy Route Path",
          "matches": {
            "a-route-path-lazy": true
          },
          "options": {}
        },
        {
          "content": "this.route.paramMap\n\t.pipe(map(params => params.get('id')), tap(id => (this.id = +id)))\n\t.subscribe(id => {$1});\n$0",
          "doc": "Angular - subscribe to routing parameters",
          "grammar": "lsp",
          "label": "Routing Params - Subscribe",
          "matches": {
            "a-route-params-subscribe": true
          },
          "options": {}
        },
        {
          "content": "return this.httpClient.get('${1:url}');$0",
          "doc": "Angular HttpClient.get",
          "grammar": "lsp",
          "label": "HttpClient.get",
          "matches": {
            "a-httpclient-get": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor(private httpClient: HttpClient) { }\n\t$0\n}",
          "doc": "Angular service with HttpClient",
          "grammar": "lsp",
          "label": "Angular HttpClient Service",
          "matches": {
            "a-service-httpclient": true
          },
          "options": {}
        },
        {
          "content": "import { HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LogInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst started = Date.now();\n\t\treturn next.handle(req).pipe(\n\t\t\ttap(event => {\n\t\t\t\tif (event instanceof HttpResponse) {\n\t\t\t\t\tconst elapsed = Date.now() - started;\n\t\t\t\t\tconsole.log(`Request for \\${req.urlWithParams} took \\${elapsed} ms.`);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}",
          "doc": "Angular HttpInterceptor for Logging HttpClient",
          "grammar": "lsp",
          "label": "Angular HttpInterceptor for Logging",
          "matches": {
            "a-http-interceptor-logging": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeaderInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst headers = req.headers\n\t\t\t.set('Content-Type', 'application/json');\n\t\tconst authReq = req.clone({ headers });\n\t\treturn next.handle(authReq);\n\t}\n}",
          "doc": "Angular HttpInterceptor for headers HttpClient",
          "grammar": "lsp",
          "label": "Angular HttpInterceptor for Headers",
          "matches": {
            "a-http-interceptor-headers": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpEvent, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class ${2:Your}Interceptor implements HttpInterceptor {\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\treturn next.handle(req);\n\t}\n}",
          "doc": "Empty Angular HttpInterceptor for HttpClient",
          "grammar": "lsp",
          "label": "Angular HttpInterceptor - Empty",
          "matches": {
            "a-http-interceptor": true
          },
          "options": {}
        },
        {
          "content": "@Output() ${1:eventName} = new EventEmitter<${2:eventType}>();",
          "doc": "Angular @Output event and emitter",
          "grammar": "lsp",
          "label": "Output Event",
          "matches": {
            "a-output-event": true
          },
          "options": {}
        },
        {
          "content": "this.${1:service}.${2:function}\n\t.subscribe(${3:arg} => this.${4:property} = ${3:arg});\n$0",
          "doc": "Angular observable subscribe",
          "grammar": "lsp",
          "label": "Subscribe",
          "matches": {
            "a-subscribe": true
          },
          "options": {}
        },
        {
          "content": "import { Component } from '@angular/core';\n\n@Component({\n\tselector: '${1:prefix-app}',\n\ttemplate: `\n\t\t<router-outlet></router-outlet>\n\t\t`\n})\nexport class ${2:App}Component { }\n$0",
          "doc": "Angular App root component",
          "grammar": "lsp",
          "label": "Angular Root Component",
          "matches": {
            "a-component-root": true
          },
          "options": {}
        },
        {
          "content": "import { NgModule } from '@angular/core';\nimport { BrowserModule  } from '@angular/platform-browser';\nimport { HttpModule } from '@angular/http';\n\nimport { ${1:App}Component } from './${1:app}.component';\n\n@NgModule({\n\timports: [\n\t\tBrowserModule,\n\t\tHttpModule,\n\t],\n\tdeclarations: [${1:App}Component],\n\tbootstrap: [${1:App}Component],\n})\nexport class ${1:App}Module { }\n$0",
          "doc": "Angular Root Module",
          "grammar": "lsp",
          "label": "Angular Root Module",
          "matches": {
            "a-module-root": true
          },
          "options": {}
        },
        {
          "content": "import { Routes } from '@angular/router';\n\nexport const routes: Routes = [${0}]",
          "doc": "Route definitions",
          "grammar": "lsp",
          "label": "Route definitions",
          "matches": {
            "a-routes": true
          },
          "options": {}
        },
        {
          "content": "import { NgModule } from '@angular/core';\n\nimport { ${1:Name}Component } from './${2:name}.component';\n\n@NgModule({\n\timports: [],\n\texports: [],\n\tdeclarations: [${1:Name}Component],\n\tproviders: [],\n})\nexport class ${1:Name}Module { }\n$0",
          "doc": "Angular Module",
          "grammar": "lsp",
          "label": "Angular Module",
          "matches": {
            "a-module": true
          },
          "options": {}
        },
        {
          "content": "import { Directive } from '@angular/core';\n\n@Directive({ selector: '[${1:selector-name}]' })\nexport class ${2:Name}Directive {\n\tconstructor() { }\n}",
          "doc": "Angular directive",
          "grammar": "lsp",
          "label": "Angular Directive",
          "matches": {
            "a-directive": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivate, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivate {\n\tconstructor() { }\n\n\tcanActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
          "doc": "Angular CanActivate guard",
          "grammar": "lsp",
          "label": "Angular CanActivate Guard",
          "matches": {
            "a-guard-can-activate": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivateChild, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivateChild {\n\tconstructor() { }\n\n\tcanActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
          "doc": "Angular CanActivateChild guard",
          "grammar": "lsp",
          "label": "Angular CanActivateChild Guard",
          "matches": {
            "a-guard-can-activate-child": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { CanLoad, Route } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanLoad {\n\tconstructor() { }\n\n\tcanLoad(route: Route) {\n\t\treturn true;$0\n\t}\n}",
          "doc": "Angular CanLoad guard",
          "grammar": "lsp",
          "label": "Angular CanLoad Guard",
          "matches": {
            "a-guard-can-load": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanDeactivate, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { ${2:ComponentName}Component } from './${3:filename}.component';\n\n// Consider using this interface for all CanDeactivate guards,\n// and have your components implement this interface, too.\n//\n//   e.g. export class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {\n//\n// export interface CanComponentDeactivate {\n// canDeactivate: () => any;\n// }\n\n@Injectable({providedIn: ${4:'root'}})\nexport class ${1:Name}Guard implements CanDeactivate<${2:ComponentName}Component> {\n\tcanDeactivate(\n\t\tcomponent: ${2:ComponentName}Component,\n\t\tcurrentRoute: ActivatedRouteSnapshot, \n\t\tcurrentState: RouterStateSnapshot\n\t): Observable<boolean>|Promise<boolean>|boolean {\n\t\treturn false;$0\n\t}\n}",
          "doc": "Angular CanDeactivate guard",
          "grammar": "lsp",
          "label": "Angular CanDeactivate Guard",
          "matches": {
            "a-guard-can-deactivate": true
          },
          "options": {}
        },
        {
          "content": "import { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nexport class PreloadSelectedModulesList implements PreloadingStrategy {\n\tpreload(route: Route, load: Function): Observable<any> {\n\t\treturn route.data && route.data['${1:preload}'] ? load() : of(null);\n\t}\n}\n$0",
          "doc": "Angular opt-in preload strategy",
          "grammar": "lsp",
          "label": "Angular Opt-In Preload Strategy",
          "matches": {
            "a-preload-opt-in-strategy": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, EMPTY } from 'rxjs';\n\n// avoid typing issues for now\nexport declare var navigator;\n\n@Injectable({ providedIn: 'root' })\nexport class NetworkAwarePreloadStrategy implements PreloadingStrategy {\n\tpreload(route: Route, load: () => Observable<any>): Observable<any> {\n\t\treturn this.hasGoodConnection() ? load() : EMPTY;\n\t}\n\n\thasGoodConnection(): boolean {\n\t\tconst conn = navigator.connection;\n\t\tif (conn) {\n\t\t\tif (conn.saveData) {\n\t\t\t\treturn false; // save data mode is enabled, so dont preload\n\t\t\t}\n\t\t\tconst avoidTheseConnections = ['slow-2g', '2g' /* , '3g', '4g' */];\n\t\t\tconst effectiveType = conn.effectiveType || '';\n\t\t\tif (avoidTheseConnections.includes(effectiveType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}",
          "doc": "Angular network aware preload strategy",
          "grammar": "lsp",
          "label": "Angular Network-Aware Preload Strategy",
          "matches": {
            "a-preload-network-strategy": true
          },
          "options": {}
        },
        {
          "content": "checkEvents() {\n\tthis.router.events.subscribe(event => {\n\t\tswitch (true) {\n\t\t\tcase event instanceof ${1:eventName}:\n\t\t\t\t$0\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t});\n}",
          "doc": "Angular Router Events",
          "grammar": "lsp",
          "label": "Angular Router Events",
          "matches": {
            "a-router-events": true
          },
          "options": {}
        },
        {
          "content": "constructor( @Optional() @SkipSelf() parentModule: ${1:ModuleName} {\n\tif (parentModule) {\n\t\tconst msg = `${1:ModuleName} has already been loaded. \n\t\t\tImport ${1:ModuleName} once, only, in the root AppModule.`;\n\t\tthrow new Error(msg);\n\t}\n}",
          "doc": "Angular Module SkipSelf constructor",
          "grammar": "lsp",
          "label": "Angular Module SkipSelf Constructor",
          "matches": {
            "a-ctor-skip-self": true
          },
          "options": {}
        },
        {
          "content": "import { ${1:Observable} } from 'rxjs';\n$0",
          "doc": "RxJs import",
          "grammar": "lsp",
          "label": "RxJs Import",
          "matches": {
            "a-rxjs-import": true
          },
          "options": {}
        },
        {
          "content": "import { ${1:map} } from 'rxjs/operators';\n$0",
          "doc": "RxJs import",
          "grammar": "lsp",
          "label": "RxJs Operator Import",
          "matches": {
            "a-rxjs-operator-import": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport { Resolve, ActivatedRouteSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: ${1:'root'} })\nexport class ${2:YourResolver} implements Resolve<${3:ObjectToResolve}> {\n\tresolve(route: ActivatedRouteSnapshot): Observable<${3:ObjectToResolve}> | Promise<${3:ObjectToResolve}> | ${3:ObjectToResolve} {\n\t\treturn ${0};\n\t}\n}",
          "doc": "Angular Resolver",
          "grammar": "lsp",
          "label": "Angular Resolver",
          "matches": {
            "a-resolver": true
          },
          "options": {}
        },
        {
          "content": "import { NgModule } from '@angular/core';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreModule } from '@ngrx/store';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { environment } from '../../environments/environment';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot({}),\n    EffectsModule.forRoot([]),\n    environment.production ? [] : StoreDevtoolsModule.instrument()\n  ]\n})\nexport class $1StoreModule {}",
          "doc": "NgRx Store Module",
          "grammar": "lsp",
          "label": "NgRx Store Module",
          "matches": {
            "a-ngrx-store-module": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}');",
          "doc": "Creates an NgRx Action",
          "grammar": "lsp",
          "label": "NgRx Create Action",
          "matches": {
            "a-ngrx-create-action": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}', props<{${4:key}: ${5:type}}>());",
          "doc": "Creates an NgRx Action with Props",
          "grammar": "lsp",
          "label": "NgRx Create Action w/ Props",
          "matches": {
            "a-ngrx-create-action-props": true
          },
          "options": {}
        },
        {
          "content": "const ${1:feature}Reducer = createReducer(\n\tinitialState,\n\ton($1Actions.action, state => ({ ...state, ${2:prop}: ${3:updatedValue} })),\n);\n\nexport function reducer(state: State | undefined, action: Action) {\n\treturn $1Reducer(state, action);\n}",
          "doc": "Creates an NgRx Reducer",
          "grammar": "lsp",
          "label": "NgRx Create Reducer",
          "matches": {
            "a-ngrx-create-reducer": true
          },
          "options": {}
        },
        {
          "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State) => state.${3:property}\n);",
          "doc": "Creates an NgRx Selector",
          "grammar": "lsp",
          "label": "NgRx Create Selector",
          "matches": {
            "a-ngrx-create-selector": true
          },
          "options": {}
        },
        {
          "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State, props) => ${3:selectLogic}\n);",
          "doc": "Creates an NgRx Selector using props",
          "grammar": "lsp",
          "label": "NgRx Create Selector w/ Props",
          "matches": {
            "a-ngrx-create-selector-props": true
          },
          "options": {}
        },
        {
          "content": "EntityDataModule.forRoot(${1:entityConfig}),",
          "doc": "Import NgRx Entity Data Module",
          "grammar": "lsp",
          "label": "NgRx Data Import Entity Data Module",
          "matches": {
            "a-ngrx-data-entity-data-module-import": true
          },
          "options": {}
        },
        {
          "content": "import { EntityMetadataMap } from '@ngrx/data';\n\nconst entityMetadata: EntityMetadataMap = {\n  ${1:Model1}: {},${0}\n};\n\nexport const entityConfig = {\n  entityMetadata\n};",
          "doc": "NgRx Data Entity Metadata",
          "grammar": "lsp",
          "label": "NgRx Data Entity Metadata",
          "matches": {
            "a-ngrx-data-entity-metadata": true
          },
          "options": {}
        },
        {
          "content": "import { Injectable } from '@angular/core';\nimport {\n  EntityCollectionServiceBase,\n  EntityCollectionServiceElementsFactory\n} from '@ngrx/data';\nimport { ${1:Model} } from '${2:../core}';\n\n@Injectable({ providedIn: ${3:'root'} })\nexport class ${1:Model}Service extends EntityCollectionServiceBase<${1:Model}> {\n  constructor(serviceElementsFactory: EntityCollectionServiceElementsFactory) {\n    super('${1:Model}', serviceElementsFactory);\n  }\n}",
          "doc": "NgRx Data Entity Collection Data Service",
          "grammar": "lsp",
          "label": "NgRx Data Entity Collection Data Service",
          "matches": {
            "a-ngrx-data-entity-collection-data-service": true
          },
          "options": {}
        },
        {
          "content": "${1:trackBy}(index: number, ${2:name}: ${3:model}): ${4:number} {\n  return ${2:name}${5:.id};$0\n}",
          "doc": "TrackBy Function",
          "grammar": "lsp",
          "label": "TrackBy Function",
          "matches": {
            "a-trackby": true
          },
          "options": {}
        }
      ]
    }
  ],
  "vscode-es7-javascript-react-snippets/snippets": [
    {
      "snippets": []
    },
    {
      "snippets": [
        {
          "content": "import ${2:moduleName} from '${1:module}'$0",
          "doc": "",
          "grammar": "lsp",
          "label": "import",
          "matches": {
            "imp": true
          },
          "options": {}
        },
        {
          "content": "import '${1:module}'$0",
          "doc": "",
          "grammar": "lsp",
          "label": "importNoModuleName",
          "matches": {
            "imn": true
          },
          "options": {}
        },
        {
          "content": "import { $2 } from '${1:module}'$0",
          "doc": "",
          "grammar": "lsp",
          "label": "importDestructing",
          "matches": {
            "imd": true
          },
          "options": {}
        },
        {
          "content": "import * as ${2:alias} from '${1:module}'$0",
          "doc": "",
          "grammar": "lsp",
          "label": "importEverything",
          "matches": {
            "ime": true
          },
          "options": {}
        },
        {
          "content": "import { ${2:originalName} as ${3:alias} } from '${1:module}'$0",
          "doc": "",
          "grammar": "lsp",
          "label": "importAs",
          "matches": {
            "ima": true
          },
          "options": {}
        },
        {
          "content": "export default $1$0",
          "doc": "",
          "grammar": "lsp",
          "label": "exportDefault",
          "matches": {
            "exp": true
          },
          "options": {}
        },
        {
          "content": "export { $2 } from '${1:module}'$0",
          "doc": "",
          "grammar": "lsp",
          "label": "exportDestructing",
          "matches": {
            "exd": true
          },
          "options": {}
        },
        {
          "content": "export { ${2:originalName} as ${3:alias} } from '${1:module}'$0",
          "doc": "",
          "grammar": "lsp",
          "label": "exportAs",
          "matches": {
            "exa": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:functionName} = (${2:params}) => {\n\t$0\n}\n",
          "doc": "Export named function in ES7 syntax",
          "grammar": "lsp",
          "label": "exportNamedFunction",
          "matches": {
            "enf": true
          },
          "options": {}
        },
        {
          "content": "export default (${1:params}) => {\n\t$0\n}\n",
          "doc": "Export default function in ES7 syntax",
          "grammar": "lsp",
          "label": "exportDefaultFunction",
          "matches": {
            "edf": true
          },
          "options": {}
        },
        {
          "content": "${1:methodName} = (${2:params}) => {\n\t${0}\n}\n",
          "doc": "Creates a method inside a class in ES7 syntax",
          "grammar": "lsp",
          "label": "method",
          "matches": {
            "met": true
          },
          "options": {}
        },
        {
          "content": "get ${1:propertyName}() {\n\treturn this.${0}\n}\n",
          "doc": "Creates a getter property inside a class in ES7 syntax",
          "grammar": "lsp",
          "label": "propertyGet",
          "matches": {
            "pge": true
          },
          "options": {}
        },
        {
          "content": "set ${1:propertyName}(${2:value}) {\n\t${0}\n}\n",
          "doc": "Creates a setter property inside a class in ES7 syntax",
          "grammar": "lsp",
          "label": "propertySet",
          "matches": {
            "pse": true
          },
          "options": {}
        },
        {
          "content": "${1:array}.forEach(${2:currentItem} => {\n\t${0}\n})\n",
          "doc": "Creates a forEach statement in ES7 syntax",
          "grammar": "lsp",
          "label": "forEach",
          "matches": {
            "fre": true
          },
          "options": {}
        },
        {
          "content": "for(let ${1:item} of ${2:object}) {\n\t${0}\n}\n",
          "doc": "Iterating over property names of iterable objects",
          "grammar": "lsp",
          "label": "forOf",
          "matches": {
            "fof": true
          },
          "options": {}
        },
        {
          "content": "for(let ${1:item} in ${2:object}) {\n\t${0}\n}\n",
          "doc": "Iterating over property values of iterable objects",
          "grammar": "lsp",
          "label": "forIn",
          "matches": {
            "fin": true
          },
          "options": {}
        },
        {
          "content": "(${1:params}) => {\n\t${2}\n}",
          "doc": "Creates an anonymous function in ES7 syntax",
          "grammar": "lsp",
          "label": "anonymousFunction",
          "matches": {
            "anfn": true
          },
          "options": {}
        },
        {
          "content": "const ${1:name} = (${2:params}) => {\n\t${3}\n}\n",
          "doc": "Creates a named function in ES7 syntax",
          "grammar": "lsp",
          "label": "namedFunction",
          "matches": {
            "nfn": true
          },
          "options": {}
        },
        {
          "content": "const {${1:propertyName}} = ${2:objectToDestruct}",
          "doc": "Creates and assigns a local variable using object destructing",
          "grammar": "lsp",
          "label": "destructingObject",
          "matches": {
            "dob": true
          },
          "options": {}
        },
        {
          "content": "const [${1:propertyName}] = ${2:arrayToDestruct}",
          "doc": "Creates and assigns a local variable using array destructing",
          "grammar": "lsp",
          "label": "destructingArray",
          "matches": {
            "dar": true
          },
          "options": {}
        },
        {
          "content": "setInterval(() => {\n\t${2}\n}, ${0:intervalInms})\n",
          "doc": "Executes the given function at specified intervals in ES7 syntax",
          "grammar": "lsp",
          "label": "setInterval",
          "matches": {
            "sti": true
          },
          "options": {}
        },
        {
          "content": "setTimeout(() => {\n\t${2}\n}, ${1:delayInms})\n",
          "doc": "Executes the given function after the specified delay in ES7 syntax",
          "grammar": "lsp",
          "label": "setTimeOut",
          "matches": {
            "sto": true
          },
          "options": {}
        },
        {
          "content": "return new Promise((resolve, reject) => {\n\t${1}\n})\n",
          "doc": "Creates and returns a new Promise in the standard ES7 syntax",
          "grammar": "lsp",
          "label": "promise",
          "matches": {
            "prom": true
          },
          "options": {}
        },
        {
          "content": "console.assert(${1:expression}, ${2:object})",
          "doc": "If the specified expression is false, the message is written to the console along with a stack trace",
          "grammar": "lsp",
          "label": "consoleAssert",
          "matches": {
            "cas": true
          },
          "options": {}
        },
        {
          "content": "console.clear()",
          "doc": "Clears the console",
          "grammar": "lsp",
          "label": "consoleClear",
          "matches": {
            "ccl": true
          },
          "options": {}
        },
        {
          "content": "console.count(${1:label})",
          "doc": "Writes the the number of times that count() has been invoked at the same line and with the same label",
          "grammar": "lsp",
          "label": "consoleCount",
          "matches": {
            "cco": true
          },
          "options": {}
        },
        {
          "content": "console.dir(${1:object})",
          "doc": "Prints a JavaScript representation of the specified object",
          "grammar": "lsp",
          "label": "consoleDir",
          "matches": {
            "cdi": true
          },
          "options": {}
        },
        {
          "content": "console.error(${1:object})",
          "doc": "Displays a message in the console and also includes a stack trace from where the method was called",
          "grammar": "lsp",
          "label": "consoleError",
          "matches": {
            "cer": true
          },
          "options": {}
        },
        {
          "content": "console.group(\"${1:label}\")",
          "doc": "Groups and indents all following output by an additional level, until console.groupEnd() is called.",
          "grammar": "lsp",
          "label": "consoleGroup",
          "matches": {
            "cgr": true
          },
          "options": {}
        },
        {
          "content": "console.groupEnd()",
          "doc": "Closes out the corresponding console.group().",
          "grammar": "lsp",
          "label": "consoleGroupEnd",
          "matches": {
            "cge": true
          },
          "options": {}
        },
        {
          "content": "console.log(${1:object})",
          "doc": "Displays a message in the console",
          "grammar": "lsp",
          "label": "consoleLog",
          "matches": {
            "clg": true
          },
          "options": {}
        },
        {
          "content": "console.trace(${1:object})",
          "doc": "Prints a stack trace from the point where the method was called",
          "grammar": "lsp",
          "label": "consoleTrace",
          "matches": {
            "ctr": true
          },
          "options": {}
        },
        {
          "content": "console.log(`${1:object}`, ${1:object})",
          "doc": "Logs property with name.",
          "grammar": "lsp",
          "label": "consoleLogObject",
          "matches": {
            "clo": true
          },
          "options": {}
        },
        {
          "content": "console.time(`${1:object}`)",
          "doc": "Console time wrapper",
          "grammar": "lsp",
          "label": "consoleTime",
          "matches": {
            "ctm": true
          },
          "options": {}
        },
        {
          "content": "console.timeEnd(`${1:object}`)",
          "doc": "Console time end wrapper",
          "grammar": "lsp",
          "label": "consoleTimeEnd",
          "matches": {
            "cte": true
          },
          "options": {}
        },
        {
          "content": "console.warn(${1:object})",
          "doc": "Displays a message in the console but also displays a yellow warning icon along with the logged message",
          "grammar": "lsp",
          "label": "consoleWarn",
          "matches": {
            "cwa": true
          },
          "options": {}
        },
        {
          "content": "console.info(${1:object})",
          "doc": "Displays a message in the console but also displays a blue information icon along with the logged message",
          "grammar": "lsp",
          "label": "consoleInfo",
          "matches": {
            "cin": true
          },
          "options": {}
        },
        {
          "content": "const { $1 } = this.props",
          "doc": "Creates and assigns a local variable using props destructing",
          "grammar": "lsp",
          "label": "destructProps",
          "matches": {
            "cp": true
          },
          "options": {}
        },
        {
          "content": "const { $1 } = this.state",
          "doc": "Creates and assigns a local variable using state destructing",
          "grammar": "lsp",
          "label": "destructState",
          "matches": {
            "cs": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React",
          "matches": {
            "imr": true
          },
          "options": {}
        },
        {
          "content": "import ReactDOM from 'react-dom'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import ReactDOM",
          "matches": {
            "imrd": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, { Component }",
          "matches": {
            "imrc": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, { Component } & PropTypes",
          "matches": {
            "imrcp": true
          },
          "options": {}
        },
        {
          "content": "import React, { PureComponent } from 'react'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, { PureComponent }",
          "matches": {
            "imrpc": true
          },
          "options": {}
        },
        {
          "content": "import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, { PureComponent } & PropTypes",
          "matches": {
            "imrpcp": true
          },
          "options": {}
        },
        {
          "content": "import React, { memo } from 'react'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, { memo }",
          "matches": {
            "imrm": true
          },
          "options": {}
        },
        {
          "content": "import React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, { memo } & PropTypes",
          "matches": {
            "imrmp": true
          },
          "options": {}
        },
        {
          "content": "import React, { useState } from 'react'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, {useState}",
          "matches": {
            "imrs": true
          },
          "options": {}
        },
        {
          "content": "import React, { useEffect } from 'react'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, {useEffect}",
          "matches": {
            "imre": true
          },
          "options": {}
        },
        {
          "content": "import React, { useRef } from 'react'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, {useRef}",
          "matches": {
            "imrr": true
          },
          "options": {}
        },
        {
          "content": "import React, { useState, useEffect } from 'react'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React, {useState, useEffect}",
          "matches": {
            "imrse": true
          },
          "options": {}
        },
        {
          "content": "import PropTypes from 'prop-types'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import PropTypes",
          "matches": {
            "impt": true
          },
          "options": {}
        },
        {
          "content": "import { BrowserRouter as Router, Route, NavLink } from 'react-router-dom'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React Router",
          "matches": {
            "imrr": true
          },
          "options": {}
        },
        {
          "content": "import { BrowserRouter as Router } from 'react-router-dom'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React Browser Router",
          "matches": {
            "imbr": true
          },
          "options": {}
        },
        {
          "content": "import { Route } from 'react-router-dom'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React Browser Router - Route",
          "matches": {
            "imbrr": true
          },
          "options": {}
        },
        {
          "content": "import { Route, Switch, NavLink, Link } from 'react-router-dom'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React Browser Router - Route Combo",
          "matches": {
            "imbrc": true
          },
          "options": {}
        },
        {
          "content": "import { Switch } from 'react-router-dom'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React Browser Router - Switch",
          "matches": {
            "imbrs": true
          },
          "options": {}
        },
        {
          "content": "import { Link } from 'react-router-dom'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React Browser Router - Link",
          "matches": {
            "imbrl": true
          },
          "options": {}
        },
        {
          "content": "import { NavLink } from 'react-router-dom'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import React Browser Router - NavLink",
          "matches": {
            "imbrnl": true
          },
          "options": {}
        },
        {
          "content": "import { connect } from 'react-redux'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "import redux statement",
          "matches": {
            "redux": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
          "doc": "Creates a React component class with ES7 module system",
          "grammar": "lsp",
          "label": "reactClassComponent",
          "matches": {
            "rcc": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "Creates a React component class with ES7 module system",
          "grammar": "lsp",
          "label": "reactClassExportComponent",
          "matches": {
            "rce": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\n\nfunction ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "Creates a React Functional Component with ES7 module system",
          "grammar": "lsp",
          "label": "reactFunctionalExportComponent",
          "matches": {
            "rfce": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
          "doc": "Creates a React Functional Component with ES7 module system",
          "grammar": "lsp",
          "label": "reactFunctionalComponent",
          "matches": {
            "rfc": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\n",
          "doc": "Creates a React Functional Component with ES7 module system with PropTypes",
          "grammar": "lsp",
          "label": "reactFunctionalComponentWithPropTypes",
          "matches": {
            "rfcp": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "Creates a React Arrow Function Component with ES7 module system",
          "grammar": "lsp",
          "label": "reactArrowFunctionExportComponent",
          "matches": {
            "rafce": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\n\nexport const ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
          "doc": "Creates a React Arrow Function Component with ES7 module system",
          "grammar": "lsp",
          "label": "reactArrowFunctionComponent",
          "matches": {
            "rafc": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "Creates a React Arrow Function Component with ES7 module system with PropTypes",
          "grammar": "lsp",
          "label": "reactArrowFunctionComponentWithPropTypes",
          "matches": {
            "rafcp": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "Creates a React component class with ES7 module system",
          "grammar": "lsp",
          "label": "reactClassExportComponentWithPropTypes",
          "matches": {
            "rcep": true
          },
          "options": {}
        },
        {
          "content": "import React, { PureComponent } from 'react'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
          "doc": "Creates a React pure component class with ES7 module system",
          "grammar": "lsp",
          "label": "reactClassPureComponent",
          "matches": {
            "rpc": true
          },
          "options": {}
        },
        {
          "content": "import React, { PureComponent } from 'react'\n\nexport class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:$TM_FILENAME_BASE}\n",
          "doc": "Creates a React pure component class with ES7 module system export",
          "grammar": "lsp",
          "label": "reactClassExportPureComponent",
          "matches": {
            "rpce": true
          },
          "options": {}
        },
        {
          "content": "import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\tstatic propTypes = {\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
          "doc": "Creates a React component class with ES7 module system",
          "grammar": "lsp",
          "label": "reactClassPureComponentWithPropTypes",
          "matches": {
            "rpcp": true
          },
          "options": {}
        },
        {
          "content": "import React, { memo } from 'react'\n\nexport default memo(function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n",
          "doc": "Creates a React Memo Function Component with ES7 module system",
          "grammar": "lsp",
          "label": "reactFunctionMemoComponent",
          "matches": {
            "rmc": true
          },
          "options": {}
        },
        {
          "content": "import React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE}} = memo(function ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "Creates a React Memo Function Component with ES7 module system with PropTypes",
          "grammar": "lsp",
          "label": "reactFunctionMemoComponentWithPropTypes",
          "matches": {
            "rmcp": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
          "doc": "Creates a React component class with PropTypes and ES7 module system",
          "grammar": "lsp",
          "label": "reactClassCompomentPropTypes",
          "matches": {
            "rccp": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
          "doc": "Creates a React component class with connected redux and ES7 module system",
          "grammar": "lsp",
          "label": "reactClassCompomentRedux",
          "matches": {
            "rcredux": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
          "doc": "Creates a React component class with PropTypes with connected redux and ES7 module system",
          "grammar": "lsp",
          "label": "reactClassCompomentReduxPropTypes",
          "matches": {
            "rcreduxp": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport { connect } from 'react-redux'\n\nexport const ${1:${TM_FILENAME_BASE}} = (props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
          "doc": "Creates a React functional component with connected redux and ES7 module system",
          "grammar": "lsp",
          "label": "reactFunctionalCompomentRedux",
          "matches": {
            "rfcredux": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport const ${1:${TM_FILENAME_BASE}} = (props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t${2:props}: ${3:PropTypes}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
          "doc": "Creates a React functional component with PropTypes with connected redux and ES7 module system",
          "grammar": "lsp",
          "label": "reactFunctionalCompomentReduxPropTypes",
          "matches": {
            "rfcreduxp": true
          },
          "options": {}
        },
        {
          "content": "const mapStateToProps = (state) => ({\n\t${1}\n})\n\nconst mapDispatchToProps = {\n\t\n}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "mappingToProps",
          "matches": {
            "reduxmap": true
          },
          "options": {}
        },
        {
          "content": "constructor(props) {\n\tsuper(props)\n\n\tthis.state = {\n\t\t $0\n\t}\n}\n",
          "doc": "Adds a default constructor for it('', () => {})the class that contains props as arguments",
          "grammar": "lsp",
          "label": "classConstructor",
          "matches": {
            "rconst": true
          },
          "options": {}
        },
        {
          "content": "state = {\n\t$1\n}\n",
          "doc": "Creates empty state object. To be used in a constructor.",
          "grammar": "lsp",
          "label": "emptyState",
          "matches": {
            "est": true
          },
          "options": {}
        },
        {
          "content": "componentWillMount() {\n\t$0\n}\n",
          "doc": "DEPRECATED!!!. Invoked once, both on the client and server, immediately before the initial rendering occurs",
          "grammar": "lsp",
          "label": "componentWillMount",
          "matches": {
            "cwm": true
          },
          "options": {}
        },
        {
          "content": "componentDidMount() {\n\t$0\n}\n",
          "doc": "Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.",
          "grammar": "lsp",
          "label": "componentDidMount",
          "matches": {
            "cdm": true
          },
          "options": {}
        },
        {
          "content": "componentWillReceiveProps(nextProps) {\n\t$0\n}\n",
          "doc": "DEPRECATED!!!. Invoked when a component is receiving new props. This method is not called for the initial render.",
          "grammar": "lsp",
          "label": "componentWillReceiveProps",
          "matches": {
            "cwr": true
          },
          "options": {}
        },
        {
          "content": "shouldComponentUpdate(nextProps, nextState) {\n\t$0\n}\n",
          "doc": "Invoked before rendering when new props or state are being received. ",
          "grammar": "lsp",
          "label": "shouldComponentUpdate",
          "matches": {
            "scu": true
          },
          "options": {}
        },
        {
          "content": "componentWillUpdate(nextProps, nextState) {\n\t$0\n}\n",
          "doc": "DEPRECATED!!!. Invoked immediately before rendering when new props or state are being received.",
          "grammar": "lsp",
          "label": "componentWillUpdate",
          "matches": {
            "cwup": true
          },
          "options": {}
        },
        {
          "content": "componentDidUpdate(prevProps, prevState) {\n\t$0\n}\n",
          "doc": "Invoked immediately after the component's updates are flushed to the DOM.",
          "grammar": "lsp",
          "label": "componentDidUpdate",
          "matches": {
            "cdup": true
          },
          "options": {}
        },
        {
          "content": "componentWillUnmount() {\n\t$0\n}\n",
          "doc": "Invoked immediately before a component is unmounted from the DOM.",
          "grammar": "lsp",
          "label": "componentWillUnmount",
          "matches": {
            "cwun": true
          },
          "options": {}
        },
        {
          "content": "static getDerivedStateFromProps(props, state) {\n\t${1}\n}",
          "doc": "Invoked right before calling the render method, both on the initial mount and on subsequent updates.",
          "grammar": "lsp",
          "label": "getDerivedStateFromProps",
          "matches": {
            "gdsfp": true
          },
          "options": {}
        },
        {
          "content": "getSnapshotBeforeUpdate = (prevProps, prevState) => {\n\t$0\n}\n",
          "doc": "Called right before mutations are made (e.g. before the DOM is updated)",
          "grammar": "lsp",
          "label": "getSnapshotBeforeUpdate",
          "matches": {
            "gsbu": true
          },
          "options": {}
        },
        {
          "content": "render() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}",
          "doc": "Basic render.",
          "grammar": "lsp",
          "label": "componentRender",
          "matches": {
            "ren": true
          },
          "options": {}
        },
        {
          "content": "const ${1:contextName} = React.createContext()\n",
          "doc": "Create React context",
          "grammar": "lsp",
          "label": "createContext",
          "matches": {
            "rcontext": true
          },
          "options": {}
        },
        {
          "content": "this.${1:refName}Ref = React.createRef()\n",
          "doc": "Create ref statement used inside constructor",
          "grammar": "lsp",
          "label": "createRef",
          "matches": {
            "cref": true
          },
          "options": {}
        },
        {
          "content": "const ref = React.createRef()\n",
          "doc": "Forward ref statement used inside component",
          "grammar": "lsp",
          "label": "forwardRef",
          "matches": {
            "fref": true
          },
          "options": {}
        },
        {
          "content": "this.setState({$0})",
          "doc": "Performs a shallow merge of nextState into current state",
          "grammar": "lsp",
          "label": "componentSetStateObject",
          "matches": {
            "sst": true
          },
          "options": {}
        },
        {
          "content": "this.setState((state, props) => { return { $0 }})\n",
          "doc": "Performs a shallow merge of nextState into current state",
          "grammar": "lsp",
          "label": "componentSetStateFunc",
          "matches": {
            "ssf": true
          },
          "options": {}
        },
        {
          "content": "this.props.$0",
          "doc": "Access component's props",
          "grammar": "lsp",
          "label": "componentProps",
          "matches": {
            "props": true
          },
          "options": {}
        },
        {
          "content": "this.state.$0",
          "doc": "",
          "grammar": "lsp",
          "label": "componentState",
          "matches": {
            "state": true
          },
          "options": {}
        },
        {
          "content": "this.${1:methodName} = this.${1:methodName}.bind(this)$0",
          "doc": "Binds this to a method",
          "grammar": "lsp",
          "label": "bindThis",
          "matches": {
            "bnd": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:actionName} = (payload) => ({\n\ttype: ${3:type},\n\tpayload\n})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reduxAction",
          "matches": {
            "rxaction": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:constantName} = '${1:constantName}'",
          "doc": "",
          "grammar": "lsp",
          "label": "reduxConst",
          "matches": {
            "rxconst": true
          },
          "options": {}
        },
        {
          "content": "const initialState = {\n\n}\n\nexport default (state = initialState, { type, payload }) => {\n\tswitch (type) {\n\n\tcase ${1:typeName}:\n\t\treturn { ...state, ...payload }\n\n\tdefault:\n\t\treturn state\n\t}\n}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reduxReducer",
          "matches": {
            "rxreducer": true
          },
          "options": {}
        },
        {
          "content": "import { createSelector } from 'reselect'\n\nexport const ${1:selectorName} = state => state.${2:selector}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reduxSelector",
          "matches": {
            "rxselect": true
          },
          "options": {}
        },
        {
          "content": "import { createSlice } from '@reduxjs/toolkit'\n\nconst initialState = {\n\n}\n\nconst ${1:${TM_FILENAME_BASE}} = createSlice({\n\tname: ${2:sliceName},\n\tinitialState,\n\treducers: {\n\t\n\t}\n});\n\nexport const {\n\n} = ${1:${TM_FILENAME_BASE}}.actions\nexport default ${1:${TM_FILENAME_BASE}}.reducer",
          "doc": "",
          "grammar": "lsp",
          "label": "reduxSlice",
          "matches": {
            "rxslice": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\nimport { Text, View } from 'react-native'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativeComponent",
          "matches": {
            "rnc": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\nimport { Text, StyleSheet, View } from 'react-native'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nconst styles = StyleSheet.create({})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativeComponentWithStyles",
          "matches": {
            "rncs": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\nimport { Text, View } from 'react-native'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativeComponentExport",
          "matches": {
            "rnce": true
          },
          "options": {}
        },
        {
          "content": "import React, { PureComponent } from 'react'\nimport { Text, View } from 'react-native'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativePureComponent",
          "matches": {
            "rnpc": true
          },
          "options": {}
        },
        {
          "content": "import React, { PureComponent } from 'react'\nimport { Text, View } from 'react-native'\n\nexport class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativePureComponentExport",
          "matches": {
            "rnpce": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react'\nimport { View, Text } from 'react-native'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
          "doc": "Creates a React Native component class with PropTypes with connected redux and ES7 module system",
          "grammar": "lsp",
          "label": "reactNativeClassComponentRedux",
          "matches": {
            "rncredux": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport { View, Text } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativeFunctionalExportComponent",
          "matches": {
            "rnfe": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport { StyleSheet, Text, View } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\nconst styles = StyleSheet.create({})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativeFunctionalExportComponentWithStyles",
          "matches": {
            "rnfes": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport { View, Text } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativeFunctionalComponent",
          "matches": {
            "rnf": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport { StyleSheet, Text, View } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nconst styles = StyleSheet.create({})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativeFunctionalComponentWithStyles",
          "matches": {
            "rnfs": true
          },
          "options": {}
        },
        {
          "content": "import { ${1:moduleName} } from 'react-native'",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativeImport",
          "matches": {
            "imrn": true
          },
          "options": {}
        },
        {
          "content": "const styles = StyleSheet.create({\n\t${1:style}\n})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "reactNativeStyles",
          "matches": {
            "rnstyle": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.array,",
          "doc": "Array prop type",
          "grammar": "lsp",
          "label": "propTypeArray",
          "matches": {
            "pta": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.array.isRequired,",
          "doc": "Array prop type required",
          "grammar": "lsp",
          "label": "propTypeArrayRequired",
          "matches": {
            "ptar": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.bool,",
          "doc": "Bool prop type",
          "grammar": "lsp",
          "label": "propTypeBool",
          "matches": {
            "ptb": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.bool.isRequired,",
          "doc": "Bool prop type required",
          "grammar": "lsp",
          "label": "propTypeBoolRequired",
          "matches": {
            "ptbr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.func,",
          "doc": "Func prop type",
          "grammar": "lsp",
          "label": "propTypeFunc",
          "matches": {
            "ptf": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.func.isRequired,",
          "doc": "Func prop type required",
          "grammar": "lsp",
          "label": "propTypeFuncRequired",
          "matches": {
            "ptfr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.number,",
          "doc": "Number prop type",
          "grammar": "lsp",
          "label": "propTypeNumber",
          "matches": {
            "ptn": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.number.isRequired,",
          "doc": "Number prop type required",
          "grammar": "lsp",
          "label": "propTypeNumberRequired",
          "matches": {
            "ptnr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.object,",
          "doc": "Object prop type",
          "grammar": "lsp",
          "label": "propTypeObject",
          "matches": {
            "pto": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.object.isRequired,",
          "doc": "Object prop type required",
          "grammar": "lsp",
          "label": "propTypeObjectRequired",
          "matches": {
            "ptor": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.string,",
          "doc": "String prop type",
          "grammar": "lsp",
          "label": "propTypeString",
          "matches": {
            "pts": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.string.isRequired,",
          "doc": "String prop type required",
          "grammar": "lsp",
          "label": "propTypeStringRequired",
          "matches": {
            "ptsr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.node,",
          "doc": "Anything that can be rendered: numbers, strings, elements or an array",
          "grammar": "lsp",
          "label": "propTypeNode",
          "matches": {
            "ptnd": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.node.isRequired,",
          "doc": "Anything that can be rendered: numbers, strings, elements or an array required",
          "grammar": "lsp",
          "label": "propTypeNodeRequired",
          "matches": {
            "ptndr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.element,",
          "doc": "React element prop type",
          "grammar": "lsp",
          "label": "propTypeElement",
          "matches": {
            "ptel": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.element.isRequired,",
          "doc": "React element prop type required",
          "grammar": "lsp",
          "label": "propTypeElementRequired",
          "matches": {
            "ptelr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.instanceOf($0),",
          "doc": "Is an instance of a class prop type",
          "grammar": "lsp",
          "label": "propTypeInstanceOf",
          "matches": {
            "pti": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.instanceOf($0).isRequired,",
          "doc": "Is an instance of a class prop type required",
          "grammar": "lsp",
          "label": "propTypeInstanceOfRequired",
          "matches": {
            "ptir": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.oneOf(['$0']),",
          "doc": "Prop type limited to specific values by treating it as an enum",
          "grammar": "lsp",
          "label": "propTypeEnum",
          "matches": {
            "pte": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.oneOf(['$0']).isRequired,",
          "doc": "Prop type limited to specific values by treating it as an enum required",
          "grammar": "lsp",
          "label": "propTypeEnumRequired",
          "matches": {
            "pter": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.oneOfType([\n\t$0\n]),",
          "doc": "An object that could be one of many types",
          "grammar": "lsp",
          "label": "propTypeOneOfType",
          "matches": {
            "ptet": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.oneOfType([\n\t$0\n]).isRequired,",
          "doc": "An object that could be one of many types required",
          "grammar": "lsp",
          "label": "propTypeOneOfTypeRequired",
          "matches": {
            "ptetr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.arrayOf($0),",
          "doc": "An array of a certain type",
          "grammar": "lsp",
          "label": "propTypeArrayOf",
          "matches": {
            "ptao": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.arrayOf($0).isRequired,",
          "doc": "An array of a certain type required",
          "grammar": "lsp",
          "label": "propTypeArrayOfRequired",
          "matches": {
            "ptaor": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.objectOf($0),",
          "doc": "An object with property values of a certain type",
          "grammar": "lsp",
          "label": "propTypeObjectOf",
          "matches": {
            "ptoo": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.objectOf($0).isRequired,",
          "doc": "An object with property values of a certain type required",
          "grammar": "lsp",
          "label": "propTypeObjectOfRequired",
          "matches": {
            "ptoor": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.shape({\n\t$0\n}),",
          "doc": "An object taking on a particular shape",
          "grammar": "lsp",
          "label": "propTypeShape",
          "matches": {
            "ptsh": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.shape({\n\t$0\n}).isRequired,",
          "doc": "An object taking on a particular shape required",
          "grammar": "lsp",
          "label": "propTypeShapeRequired",
          "matches": {
            "ptshr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.exact({\n\t$0\n}),",
          "doc": "An object with warnings on extra properties",
          "grammar": "lsp",
          "label": "propTypeExact",
          "matches": {
            "ptex": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.exact({\n\t$0\n}).isRequired,",
          "doc": "An object with warnings on extra properties required",
          "grammar": "lsp",
          "label": "propTypeExactRequired",
          "matches": {
            "ptexr": true
          },
          "options": {}
        },
        {
          "content": "static propTypes = {\n$0\n}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "staticPropTpyes",
          "matches": {
            "ptypes": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.any,",
          "doc": "Any prop type",
          "grammar": "lsp",
          "label": "propTypeAny",
          "matches": {
            "ptany": true
          },
          "options": {}
        },
        {
          "content": "/**\n * ${0}\n */",
          "doc": "",
          "grammar": "lsp",
          "label": "Comment Big Block",
          "matches": {
            "cmmb": true
          },
          "options": {}
        },
        {
          "content": "describe('$1', () => {\n\t$0\n})\n",
          "doc": "Testing `describe` block",
          "grammar": "lsp",
          "label": "describeBlock",
          "matches": {
            "desc": true
          },
          "options": {}
        },
        {
          "content": "test('should $1', () => {\n\t$0\n})\n",
          "doc": "Testing `test` block",
          "grammar": "lsp",
          "label": "testBlock",
          "matches": {
            "test": true
          },
          "options": {}
        },
        {
          "content": "test('should $1', async () => {\n\t$0\n})\n",
          "doc": "Testing `asynchronous test` block",
          "grammar": "lsp",
          "label": "testAsyncBlock",
          "matches": {
            "testa": true
          },
          "options": {}
        },
        {
          "content": "it('should $1', () => {\n\t$0\n})\n",
          "doc": "Testing `it` block",
          "grammar": "lsp",
          "label": "itBlock",
          "matches": {
            "tit": true
          },
          "options": {}
        },
        {
          "content": "it('should $1', async () => {\n\t$0\n})\n",
          "doc": "Testing asynchronous `it` block",
          "grammar": "lsp",
          "label": "itAsyncBlock",
          "matches": {
            "tita": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport renderer from 'react-test-renderer'\n\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "setupReactTest",
          "matches": {
            "stest": true
          },
          "options": {}
        },
        {
          "content": "import 'react-native'\nimport React from 'react'\nimport renderer from 'react-test-renderer'\n\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "setupReactNativeTest",
          "matches": {
            "sntest": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t <${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
          "doc": "Create test component",
          "grammar": "lsp",
          "label": "setupReactComponentTestWithRedux",
          "matches": {
            "srtest": true
          },
          "options": {}
        },
        {
          "content": "import 'react-native'\nimport React from 'react'\nimport renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t\t<${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "setupReactNativeTestWithRedux",
          "matches": {
            "snrtest": true
          },
          "options": {}
        },
        {
          "content": "import { compose, graphql } from 'react-apollo'\n",
          "doc": "",
          "grammar": "lsp",
          "label": "graphQLForComponent",
          "matches": {
            "graphql": true
          },
          "options": {}
        },
        {
          "content": "export default compose(\n\tgraphql(${1:queryOrMutation}, { name: ${2:name} }),\n)(${1:${TM_FILENAME_BASE}})",
          "doc": "",
          "grammar": "lsp",
          "label": "exportGraphQL",
          "matches": {
            "expgql": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport const mapStateToProps = state => ({\n\n})\n\nexport const mapDispatchToProps = {\n \n}\n\nexport const ${1:hocComponentName} = (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n\nexport default WrapperComponent => connect(mapStateToProps, mapDispatchToProps)(${1:hocComponentName}(WrapperComponent))\n",
          "doc": "",
          "grammar": "lsp",
          "label": "hocComponentWithRedux",
          "matches": {
            "hocredux": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nexport default (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "hocComponent",
          "matches": {
            "hoc": true
          },
          "options": {}
        },
        {
          "content": "useEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t}\n}, [${3:input}])",
          "doc": "",
          "grammar": "lsp",
          "label": "useEffect",
          "matches": {
            "useEffect": true
          },
          "options": {}
        },
        {
          "content": "const ${1:context} = useContext(${2:contextValue})",
          "doc": "",
          "grammar": "lsp",
          "label": "useContext",
          "matches": {
            "useContext": true
          },
          "options": {}
        },
        {
          "content": "const [state, dispatch] = useReducer(${1:reducer}, ${2:initialState}, ${3:init})",
          "doc": "",
          "grammar": "lsp",
          "label": "useReducer",
          "matches": {
            "useReducer": true
          },
          "options": {}
        },
        {
          "content": "useCallback(\n\t() => {\n\t\t${1:callback}\n\t},\n\t[${2:input}],\n)",
          "doc": "",
          "grammar": "lsp",
          "label": "useCallback",
          "matches": {
            "useCallback": true
          },
          "options": {}
        },
        {
          "content": "useMemo(() => ${1:function}, ${2:input})",
          "doc": "",
          "grammar": "lsp",
          "label": "useMemo",
          "matches": {
            "useMemo": true
          },
          "options": {}
        },
        {
          "content": "const ${1:ref} = useRef(${2:initialValue})",
          "doc": "",
          "grammar": "lsp",
          "label": "useRef",
          "matches": {
            "useRef": true
          },
          "options": {}
        },
        {
          "content": "useImperativeHandle(\n\t${1:ref},\n\t() => {\n\t\t${2:handler}\n\t},\n\t[${3:input}],\n)",
          "doc": "",
          "grammar": "lsp",
          "label": "useImperativeHandle",
          "matches": {
            "useImperativeHandle": true
          },
          "options": {}
        },
        {
          "content": "useDebugValue(${1:value})",
          "doc": "",
          "grammar": "lsp",
          "label": "useDebugValue",
          "matches": {
            "useDebugValue": true
          },
          "options": {}
        },
        {
          "content": "useLayoutEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t};\n}, [${3:input}])",
          "doc": "",
          "grammar": "lsp",
          "label": "useLayoutEffect",
          "matches": {
            "useLayoutEffect": true
          },
          "options": {}
        },
        {
          "content": "const ${1:state} = useSelector(state => state.${1:state})",
          "doc": "",
          "grammar": "lsp",
          "label": "useSelector",
          "matches": {
            "useSelector": true
          },
          "options": {}
        },
        {
          "content": "const dispatch = useDispatch()",
          "doc": "",
          "grammar": "lsp",
          "label": "useDispatch",
          "matches": {
            "useDispatch": true
          },
          "options": {}
        },
        {
          "content": "typeof ${0}",
          "doc": "",
          "grammar": "lsp",
          "label": "typeof",
          "matches": {
            "tpf": true
          },
          "options": {}
        },
        {
          "content": "function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "Creates a React 17 Functional Component with ES7 module system",
          "grammar": "lsp",
          "label": "_reactFunctionalExportComponent",
          "matches": {
            "_rfce": true
          },
          "options": {}
        },
        {
          "content": "export default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
          "doc": "Creates a React 17 Functional Component with ES7 module system",
          "grammar": "lsp",
          "label": "_reactFunctionalComponent",
          "matches": {
            "_rfc": true
          },
          "options": {}
        },
        {
          "content": "import PropTypes from 'prop-types'\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\n",
          "doc": "Creates a React 17 Functional Component with ES7 module system with PropTypes",
          "grammar": "lsp",
          "label": "_reactFunctionalComponentWithPropTypes",
          "matches": {
            "_rfcp": true
          },
          "options": {}
        },
        {
          "content": "const ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "Creates a React 17 Arrow Function Component with ES7 module system",
          "grammar": "lsp",
          "label": "_reactArrowFunctionExportComponent",
          "matches": {
            "_rafce": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
          "doc": "Creates a React 17 Arrow Function Component with ES7 module system",
          "grammar": "lsp",
          "label": "_reactArrowFunctionComponent",
          "matches": {
            "_rafc": true
          },
          "options": {}
        },
        {
          "content": "import PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "Creates a React 17 Arrow Function Component with ES7 module system with PropTypes",
          "grammar": "lsp",
          "label": "_reactArrowFunctionComponentWithPropTypes",
          "matches": {
            "_rafcp": true
          },
          "options": {}
        },
        {
          "content": "import { View, Text } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "_reactNativeFunctionalExportComponent",
          "matches": {
            "_rnfe": true
          },
          "options": {}
        },
        {
          "content": "import { StyleSheet, Text, View } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\nconst styles = StyleSheet.create({})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "_reactNativeFunctionalExportComponentWithStyles",
          "matches": {
            "_rnfes": true
          },
          "options": {}
        },
        {
          "content": "import { View, Text } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "_reactNativeFunctionalComponent",
          "matches": {
            "_rnf": true
          },
          "options": {}
        },
        {
          "content": "import { StyleSheet, Text, View } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nconst styles = StyleSheet.create({})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "_reactNativeFunctionalComponentWithStyles",
          "matches": {
            "_rnfs": true
          },
          "options": {}
        },
        {
          "content": "import renderer from 'react-test-renderer'\n\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "_setupReactTest",
          "matches": {
            "_stest": true
          },
          "options": {}
        },
        {
          "content": "import 'react-native'\nimport renderer from 'react-test-renderer'\n\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "_setupReactNativeTest",
          "matches": {
            "_sntest": true
          },
          "options": {}
        },
        {
          "content": "import renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t <${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
          "doc": "Create test component",
          "grammar": "lsp",
          "label": "_setupReactComponentTestWithRedux",
          "matches": {
            "_srtest": true
          },
          "options": {}
        },
        {
          "content": "import 'react-native'\nimport renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t\t<${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
          "doc": "",
          "grammar": "lsp",
          "label": "_setupReactNativeTestWithRedux",
          "matches": {
            "_snrtest": true
          },
          "options": {}
        },
        {
          "content": "import PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport const mapStateToProps = state => ({\n\n})\n\nexport const mapDispatchToProps = {\n \n}\n\nexport const ${1:hocComponentName} = (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n\nexport default WrapperComponent => connect(mapStateToProps, mapDispatchToProps)(${1:hocComponentName}(WrapperComponent))\n",
          "doc": "",
          "grammar": "lsp",
          "label": "_hocComponentWithRedux",
          "matches": {
            "_hocredux": true
          },
          "options": {}
        },
        {
          "content": "import PropTypes from 'prop-types'\n\nexport default (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n",
          "doc": "",
          "grammar": "lsp",
          "label": "_hocComponent",
          "matches": {
            "_hoc": true
          },
          "options": {}
        },
        {
          "content": "const ${1:${TM_FILENAME_BASE}} = () => {\n\t$2\n}\n\nexport default ${1:${TM_FILENAME_BASE}}",
          "doc": "Creates a React Custom Hook with ES7 module system",
          "grammar": "lsp",
          "label": "reactCustomHook",
          "matches": {
            "rch": true
          },
          "options": {}
        }
      ]
    }
  ],
  "vscode-javascript/snippets": [
    {
      "snippets": []
    },
    {
      "snippets": [
        {
          "content": "import ${2:moduleName} from '${1:module}';$0",
          "doc": "Imports entire module statement in ES6 syntax",
          "grammar": "lsp",
          "label": "import",
          "matches": {
            "imp": true
          },
          "options": {}
        },
        {
          "content": "import '${1:module}';$0",
          "doc": "Imports entire module in ES6 syntax without module name",
          "grammar": "lsp",
          "label": "importNoModuleName",
          "matches": {
            "imn": true
          },
          "options": {}
        },
        {
          "content": "import { $2 } from '${1:module}';$0",
          "doc": "Imports only a portion of the module in ES6 syntax",
          "grammar": "lsp",
          "label": "importDestructing",
          "matches": {
            "imd": true
          },
          "options": {}
        },
        {
          "content": "import * as ${2:alias} from '${1:module}';$0",
          "doc": "Imports everything as alias from the module in ES6 syntax",
          "grammar": "lsp",
          "label": "importEverything",
          "matches": {
            "ime": true
          },
          "options": {}
        },
        {
          "content": "import { ${2:originalName} as ${3:alias} } from '${1:module}';$0",
          "doc": "Imports a specific portion of the module by assigning a local alias in ES6 syntax",
          "grammar": "lsp",
          "label": "importAs",
          "matches": {
            "ima": true
          },
          "options": {}
        },
        {
          "content": "require('${1:package}');",
          "doc": "Require a package",
          "grammar": "lsp",
          "label": "require",
          "matches": {
            "rqr": true
          },
          "options": {}
        },
        {
          "content": "const ${1:packageName} = require('${1:package}');$0",
          "doc": "Require a package to const",
          "grammar": "lsp",
          "label": "requireToConst",
          "matches": {
            "req": true
          },
          "options": {}
        },
        {
          "content": "module.exports = {\n\t$0\n};\n",
          "doc": "Module exports from Common JS, node syntax at ES6",
          "grammar": "lsp",
          "label": "moduleExports",
          "matches": {
            "mde": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:exportVariable} = ${2:localVariable};\n",
          "doc": "Export named variable in ES6 syntax",
          "grammar": "lsp",
          "label": "exportNamedVariable",
          "matches": {
            "env": true
          },
          "options": {}
        },
        {
          "content": "export const ${1:functionName} = (${2:params}) => {\n\t$0\n};\n",
          "doc": "Export named function in ES6 syntax",
          "grammar": "lsp",
          "label": "exportNamedFunction",
          "matches": {
            "enf": true
          },
          "options": {}
        },
        {
          "content": "export default function ${1:${TM_FILENAME_BASE}}(${2:params}) {\n\t$0\n};\n",
          "doc": "Export default function in ES6 syntax",
          "grammar": "lsp",
          "label": "exportDefaultFunction",
          "matches": {
            "edf": true
          },
          "options": {}
        },
        {
          "content": "export default class ${1:className} {\n\t$0\n};\n",
          "doc": "Export default class in ES6 syntax",
          "grammar": "lsp",
          "label": "exportClass",
          "matches": {
            "ecl": true
          },
          "options": {}
        },
        {
          "content": "export default class ${1:className} extends ${2:baseclassName} {\n\t$0\n};\n",
          "doc": "Export default class which extends a base one in ES6 syntax",
          "grammar": "lsp",
          "label": "exportClassExtends",
          "matches": {
            "ece": true
          },
          "options": {}
        },
        {
          "content": "constructor(${1:params}) {\n\t${0}\n}",
          "doc": "Add default constructor in a class in ES6 syntax",
          "grammar": "lsp",
          "label": "constructor",
          "matches": {
            "con": true
          },
          "options": {}
        },
        {
          "content": "${1:methodName}(${2:params}) {\n\t${0}\n}",
          "doc": "Creates a method inside a class in ES6 syntax",
          "grammar": "lsp",
          "label": "method",
          "matches": {
            "met": true
          },
          "options": {}
        },
        {
          "content": "get ${1:propertyName}() {\n\treturn this.${0};\n}",
          "doc": "Creates a getter property inside a class in ES6 syntax",
          "grammar": "lsp",
          "label": "propertyGet",
          "matches": {
            "pge": true
          },
          "options": {}
        },
        {
          "content": "set ${1:propertyName}(${2:value}) {\n\t${0};\n}",
          "doc": "Creates a setter property inside a class in ES6 syntax",
          "grammar": "lsp",
          "label": "propertyset",
          "matches": {
            "pse": true
          },
          "options": {}
        },
        {
          "content": "${1:array}.forEach(${2:currentItem} => {\n\t${0}\n});",
          "doc": "Creates a forEach statement in ES6 syntax",
          "grammar": "lsp",
          "label": "forEach",
          "matches": {
            "fre": true
          },
          "options": {}
        },
        {
          "content": "for (const ${1:item} of ${2:object}) {\n\t${0}\n}",
          "doc": "Iterating over property names of iterable objects",
          "grammar": "lsp",
          "label": "forOf",
          "matches": {
            "fof": true
          },
          "options": {}
        },
        {
          "content": "for (const ${1:item} in ${2:object}) {\n\t${0}\n}",
          "doc": "Iterating over property values of iterable objects",
          "grammar": "lsp",
          "label": "forIn",
          "matches": {
            "fin": true
          },
          "options": {}
        },
        {
          "content": "(${1:params}) => {\n\t${2}\n}",
          "doc": "Creates an anonymous function in ES6 syntax",
          "grammar": "lsp",
          "label": "anonymousFunction",
          "matches": {
            "anfn": true
          },
          "options": {}
        },
        {
          "content": "const ${1:name} = (${2:params}) => {\n\t${3}\n}",
          "doc": "Creates a named function in ES6 syntax",
          "grammar": "lsp",
          "label": "namedFunction",
          "matches": {
            "nfn": true
          },
          "options": {}
        },
        {
          "content": "const {${2:propertyName}} = ${1:objectToDestruct};",
          "doc": "Creates and assigns a local variable using object destructing",
          "grammar": "lsp",
          "label": "destructingObject",
          "matches": {
            "dob": true
          },
          "options": {}
        },
        {
          "content": "const [${2:propertyName}] = ${1:arrayToDestruct};",
          "doc": "Creates and assigns a local variable using array destructing",
          "grammar": "lsp",
          "label": "destructingArray",
          "matches": {
            "dar": true
          },
          "options": {}
        },
        {
          "content": "setInterval(() => {\n\t${2}\n}, ${0:intervalInms});",
          "doc": "Executes the given function at specified intervals in ES6 syntax",
          "grammar": "lsp",
          "label": "setInterval",
          "matches": {
            "sti": true
          },
          "options": {}
        },
        {
          "content": "setTimeout(() => {\n\t${2}\n}, ${1:delayInms});",
          "doc": "Executes the given function after the specified delay in ES6 syntax",
          "grammar": "lsp",
          "label": "setTimeOut",
          "matches": {
            "sto": true
          },
          "options": {}
        },
        {
          "content": "return new Promise((resolve, reject) => {\n\t${1}\n});",
          "doc": "Creates and returns a new Promise in the standard ES6 syntax",
          "grammar": "lsp",
          "label": "promise",
          "matches": {
            "prom": true
          },
          "options": {}
        },
        {
          "content": ".then((${1:result}) => {\n\t${2}\n}).catch((${3:err}) => {\n\t${4}\n});",
          "doc": "Add the .then and .catch methods to handle promises",
          "grammar": "lsp",
          "label": "thenCatch",
          "matches": {
            "thenc": true
          },
          "options": {}
        },
        {
          "content": "console.assert(${1:expression}, ${2:object});",
          "doc": "If the specified expression is false, the message is written to the console along with a stack trace",
          "grammar": "lsp",
          "label": "consoleAssert",
          "matches": {
            "cas": true
          },
          "options": {}
        },
        {
          "content": "console.clear();",
          "doc": "Clears the console",
          "grammar": "lsp",
          "label": "consoleClear",
          "matches": {
            "ccl": true
          },
          "options": {}
        },
        {
          "content": "console.count(${1:label});",
          "doc": "Writes the the number of times that count() has been invoked at the same line and with the same label",
          "grammar": "lsp",
          "label": "consoleCount",
          "matches": {
            "cco": true
          },
          "options": {}
        },
        {
          "content": "console.debug(${1:object});",
          "doc": "Displays a message in the console. Also display a blue right arrow icon along with the logged message in Safari",
          "grammar": "lsp",
          "label": "consoleDebug",
          "matches": {
            "cdb": true
          },
          "options": {}
        },
        {
          "content": "console.dir(${1:object});",
          "doc": "Prints a JavaScript representation of the specified object",
          "grammar": "lsp",
          "label": "consoleDir",
          "matches": {
            "cdi": true
          },
          "options": {}
        },
        {
          "content": "console.error(${1:object});",
          "doc": "Displays a message in the console and also includes a stack trace from where the method was called",
          "grammar": "lsp",
          "label": "consoleError",
          "matches": {
            "cer": true
          },
          "options": {}
        },
        {
          "content": "console.group('${1:label}');",
          "doc": "Groups and indents all following output by an additional level, until console.groupEnd() is called.",
          "grammar": "lsp",
          "label": "consoleGroup",
          "matches": {
            "cgr": true
          },
          "options": {}
        },
        {
          "content": "console.groupEnd();",
          "doc": "Closes out the corresponding console.group().",
          "grammar": "lsp",
          "label": "consoleGroupEnd",
          "matches": {
            "cge": true
          },
          "options": {}
        },
        {
          "content": "console.log(${1:object});",
          "doc": "Displays a message in the console",
          "grammar": "lsp",
          "label": "consoleLog",
          "matches": {
            "clg": true
          },
          "options": {}
        },
        {
          "content": "console.log('${1:object} :>> ', ${1:object});",
          "doc": "Displays an object in the console with its name",
          "grammar": "lsp",
          "label": "consoleLogObject",
          "matches": {
            "clo": true
          },
          "options": {}
        },
        {
          "content": "console.trace(${1:object});",
          "doc": "Prints a stack trace from the point where the method was called",
          "grammar": "lsp",
          "label": "consoleTrace",
          "matches": {
            "ctr": true
          },
          "options": {}
        },
        {
          "content": "console.warn(${1:object});",
          "doc": "Displays a message in the console but also displays a yellow warning icon along with the logged message",
          "grammar": "lsp",
          "label": "consoleWarn",
          "matches": {
            "cwa": true
          },
          "options": {}
        },
        {
          "content": "console.info(${1:object});",
          "doc": "Displays a message in the console but also displays a blue information icon along with the logged message",
          "grammar": "lsp",
          "label": "consoleInfo",
          "matches": {
            "cin": true
          },
          "options": {}
        },
        {
          "content": "console.table(${1:object});",
          "doc": "Displays tabular data as a table.",
          "grammar": "lsp",
          "label": "consoleTable",
          "matches": {
            "clt": true
          },
          "options": {}
        },
        {
          "content": "console.time(${1:object});",
          "doc": "Sets starting point for execution time measurement",
          "grammar": "lsp",
          "label": "consoleTime",
          "matches": {
            "cti": true
          },
          "options": {}
        },
        {
          "content": "console.timeEnd(${1:object});",
          "doc": "Sets end point for execution time measurement",
          "grammar": "lsp",
          "label": "consoleTimeEnd",
          "matches": {
            "cte": true
          },
          "options": {}
        }
      ]
    }
  ],
  "vscode-react/snippets": [
    {
      "snippets": []
    },
    {
      "snippets": [
        {
          "content": "import React, { Component } from 'react';\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a React component class with ES6 module system",
          "grammar": "lsp",
          "label": "reactClassComponent",
          "matches": {
            "rcc": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nfunction mapStateToProps(state) {\n\treturn {\n\n\t};\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default connect(\n\tmapStateToProps,\n)(${1:${TM_FILENAME_BASE}});",
          "doc": "Creates a React component class connected to redux",
          "grammar": "lsp",
          "label": "reactReduxComponent",
          "matches": {
            "rrc": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nfunction mapStateToProps(state) {\n\treturn {\n\n\t};\n}\n\nfunction mapDispatchToProps(dispatch) {\n\treturn {\n\n\t};\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default connect(\n\tmapStateToProps,\n)(${1:${TM_FILENAME_BASE}});",
          "doc": "Creates a React component class connected to redux with dispatch",
          "grammar": "lsp",
          "label": "reactReduxDispatchComponent",
          "matches": {
            "rrdc": true
          },
          "options": {}
        },
        {
          "content": "class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n",
          "doc": "Creates a React component class with ES6 module system",
          "grammar": "lsp",
          "label": "reactJustClassComponent",
          "matches": {
            "rcjc": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a React component class with PropTypes and ES6 module system",
          "grammar": "lsp",
          "label": "reactClassComponentPropTypes",
          "matches": {
            "rccp": true
          },
          "options": {}
        },
        {
          "content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\t\n\t\t}\n\t}\n\n\tstatic getDerivedStateFromProps() {\n\t\treturn null\n\t}\n\n\tcomponentDidMount() {\n\t\t\n\t}\n\n\t// shouldComponentUpdate(nextProps, nextState) {}\n\n\tgetSnapshotBeforeUpdate(prevProps, prevState) {\n\t\treturn null\n\t}\n\n\tcomponentDidUpdate(prevProps, prevState, snapshot) {\n\t\t\n\t}\n\n\tcomponentWillUnmount() {\n\t\t\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a React component class with PropTypes and all lifecycle methods and ES6 module system",
          "grammar": "lsp",
          "label": "reactClassComponentWithMethods",
          "matches": {
            "rcfc": true
          },
          "options": {}
        },
        {
          "content": "class ${1:${TM_FILENAME_BASE}} extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.state = {};\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a React component class with constructor, empty state, proptypes and export in ES6 module system without imports. (Mostly used when React, Proptypes are provided by webpack provide plugin)",
          "grammar": "lsp",
          "label": "reactWithWebpackDefaults",
          "matches": {
            "rwwd": true
          },
          "options": {}
        },
        {
          "content": "import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a React pure component class with PropTypes and ES6 module system",
          "grammar": "lsp",
          "label": "reactPureComponent",
          "matches": {
            "rpc": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react';\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t);\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a stateless React component without PropTypes and ES6 module system",
          "grammar": "lsp",
          "label": "reactStateless",
          "matches": {
            "rsc": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n};\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a stateless React component with PropTypes and ES6 module system",
          "grammar": "lsp",
          "label": "reactStatelessProps",
          "matches": {
            "rscp": true
          },
          "options": {}
        },
        {
          "content": "import React,{ useState } from 'react';\nimport PropTypes from 'prop-types';\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n};\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a stateless React component with PropTypes and ES6 module system",
          "grammar": "lsp",
          "label": "reactHookProps",
          "matches": {
            "rhc": true
          },
          "options": {}
        },
        {
          "content": "import React, { memo } from 'react';\n\nconst ${1:${TM_FILENAME_BASE}} = memo(() => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t);\n});\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a memoized stateless React component without PropTypes and ES6 module system",
          "grammar": "lsp",
          "label": "reactMemo",
          "matches": {
            "rscm": true
          },
          "options": {}
        },
        {
          "content": "import React, { memo } from 'react';\nimport PropTypes from 'prop-types';\n\nconst ${1:${TM_FILENAME_BASE}} = memo((props) => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n});\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a memoized stateless React component with PropTypes and ES6 module system",
          "grammar": "lsp",
          "label": "reactMemoProps",
          "matches": {
            "rscpm": true
          },
          "options": {}
        },
        {
          "content": "// @flow \nimport * as React from 'react';\ntype Props = {\n\t$0\n};\nexport const ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n};",
          "doc": "Creates a stateless React component with FlowTypes and ES6 module system",
          "grammar": "lsp",
          "label": "flowStatelessComponent",
          "matches": {
            "fsc": true
          },
          "options": {}
        },
        {
          "content": "// @flow\nimport * as React from 'react';\ntype Props = {\n  $0\n};\nexport function ${1:${TM_FILENAME_BASE}}(props: Props) {\n  return (\n    <div>\n      \n    </div>\n  );\n};",
          "doc": "Creates a stateless React component as a named function with FlowTypes",
          "grammar": "lsp",
          "label": "flowStatelessFunction",
          "matches": {
            "fsf": true
          },
          "options": {}
        },
        {
          "content": "// @flow\nimport * as React from 'react';\ntype Props = {\n  $0\n};\ntype State = {\n  $1\n};\nexport class ${2:${TM_FILENAME_BASE}} extends React.Component<Props, State>{\n  render() {\n    return (\n      <div>\n        \n      </div>\n    );\n  };\n};",
          "doc": "Creates a React component class with FlowTypes",
          "grammar": "lsp",
          "label": "flowClassComponent",
          "matches": {
            "fcc": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react';\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n}\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a stateless React component as a named function without PropTypes",
          "grammar": "lsp",
          "label": "reactStatelessFunction",
          "matches": {
            "rsf": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react';\nimport PropTypes from 'prop-types';\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n}\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a stateless React component as a named function with PropTypes",
          "grammar": "lsp",
          "label": "reactStatelessFunctionProps",
          "matches": {
            "rsfp": true
          },
          "options": {}
        },
        {
          "content": "import React from 'react';\n\nconst ${1:${TM_FILENAME_BASE}} = (props) => (\n\t\t\t$0\n\t);\n\nexport default ${1:${TM_FILENAME_BASE}};",
          "doc": "Creates a stateless React component without PropTypes and ES6 module system but with Implicit Return and props",
          "grammar": "lsp",
          "label": "reactStatelessImplicitReturn",
          "matches": {
            "rsi": true
          },
          "options": {}
        },
        {
          "content": "constructor(props) {\n\tsuper(props);\n\t$0\n}\n",
          "doc": "Adds a default constructor for the class that contains props as arguments",
          "grammar": "lsp",
          "label": "classConstructor",
          "matches": {
            "con": true
          },
          "options": {}
        },
        {
          "content": "constructor(props, context) {\n\tsuper(props, context);\n\t$0\n}\n",
          "doc": "Adds a default constructor for the class that contains props and context as arguments",
          "grammar": "lsp",
          "label": "classConstructorContext",
          "matches": {
            "conc": true
          },
          "options": {}
        },
        {
          "content": "this.state = {\n\t$1\n};",
          "doc": "Creates empty state object. To be used in a constructor.",
          "grammar": "lsp",
          "label": "emptyState",
          "matches": {
            "est": true
          },
          "options": {}
        },
        {
          "content": "\ncomponentWillMount() {\n\t$0\n}\n",
          "doc": "Invoked once, both on the client and server, immediately before the initial rendering occurs",
          "grammar": "lsp",
          "label": "componentWillMount",
          "matches": {
            "cwm": true
          },
          "options": {}
        },
        {
          "content": "componentDidMount() {\n\t$0\n}\n",
          "doc": "Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.",
          "grammar": "lsp",
          "label": "componentDidMount",
          "matches": {
            "cdm": true
          },
          "options": {}
        },
        {
          "content": "componentWillReceiveProps(nextProps) {\n\t$0\n}\n",
          "doc": "Invoked when a component is receiving new props. This method is not called for the initial render. [DEPRECATION NOTE]: This method is deprecated in React 16.3",
          "grammar": "lsp",
          "label": "componentWillReceiveProps",
          "matches": {
            "cwr": true
          },
          "options": {}
        },
        {
          "content": "shouldComponentUpdate(nextProps, nextState) {\n\t$0\n}\n",
          "doc": "Invoked before rendering when new props or state are being received. ",
          "grammar": "lsp",
          "label": "shouldComponentUpdate",
          "matches": {
            "scu": true
          },
          "options": {}
        },
        {
          "content": "componentWillUpdate(nextProps, nextState) {\n\t$0\n}\n",
          "doc": "Invoked immediately before rendering when new props or state are being received. [DEPRECATION NOTE]: This method is deprecated in React 16.3",
          "grammar": "lsp",
          "label": "componentWillUpdate",
          "matches": {
            "cwup": true
          },
          "options": {}
        },
        {
          "content": "componentDidUpdate(prevProps, prevState) {\n\t$0\n}\n",
          "doc": "Invoked immediately after the component's updates are flushed to the DOM.",
          "grammar": "lsp",
          "label": "componentDidUpdate",
          "matches": {
            "cdup": true
          },
          "options": {}
        },
        {
          "content": "componentWillUnmount() {\n\t$0\n}\n",
          "doc": "Invoked immediately before a component is unmounted from the DOM.",
          "grammar": "lsp",
          "label": "componentWillUnmount",
          "matches": {
            "cwun": true
          },
          "options": {}
        },
        {
          "content": "render() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t);\n}",
          "doc": "When called, it should examine this.props and this.state and return a single child element.",
          "grammar": "lsp",
          "label": "componentRender",
          "matches": {
            "ren": true
          },
          "options": {}
        },
        {
          "content": "this.setState($0);",
          "doc": "Performs a shallow merge of nextState into current state",
          "grammar": "lsp",
          "label": "componentSetStateObject",
          "matches": {
            "sst": true
          },
          "options": {}
        },
        {
          "content": "this.setState((state, props) => { return { $0 }});\n",
          "doc": "Performs a shallow merge of nextState into current state",
          "grammar": "lsp",
          "label": "componentSetStateFunc",
          "matches": {
            "ssf": true
          },
          "options": {}
        },
        {
          "content": "this.props.$0",
          "doc": "Access component's props",
          "grammar": "lsp",
          "label": "componentProps",
          "matches": {
            "props": true
          },
          "options": {}
        },
        {
          "content": "this.state.$0",
          "doc": "Access component's state",
          "grammar": "lsp",
          "label": "componentState",
          "matches": {
            "state": true
          },
          "options": {}
        },
        {
          "content": "this.$1 = this.$1.bind(this);$0",
          "doc": "Binds the this of a method. To be used inside a constructor",
          "grammar": "lsp",
          "label": "bindThis",
          "matches": {
            "bnd": true
          },
          "options": {}
        },
        {
          "content": "${1:$TM_FILENAME_BASE}.propTypes = {\n\t$2\n};",
          "doc": "Creates empty propTypes declaration",
          "grammar": "lsp",
          "label": "propTypes",
          "matches": {
            "rpt": true
          },
          "options": {}
        },
        {
          "content": "${1:$TM_FILENAME_BASE}.defaultProps = {\n\t$2\n};",
          "doc": "Creates empty defaultProps declaration",
          "grammar": "lsp",
          "label": "defaultProps",
          "matches": {
            "rdp": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.array,",
          "doc": "Array prop type",
          "grammar": "lsp",
          "label": "propTypeArray",
          "matches": {
            "pta": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.array.isRequired,",
          "doc": "Array prop type required",
          "grammar": "lsp",
          "label": "propTypeArrayRequired",
          "matches": {
            "ptar": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.bool,",
          "doc": "Bool prop type",
          "grammar": "lsp",
          "label": "propTypeBool",
          "matches": {
            "ptb": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.bool.isRequired,",
          "doc": "Bool prop type required",
          "grammar": "lsp",
          "label": "propTypeBoolRequired",
          "matches": {
            "ptbr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.func,",
          "doc": "Func prop type",
          "grammar": "lsp",
          "label": "propTypeFunc",
          "matches": {
            "ptf": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.func.isRequired,",
          "doc": "Func prop type required",
          "grammar": "lsp",
          "label": "propTypeFuncRequired",
          "matches": {
            "ptfr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.number,",
          "doc": "Number prop type",
          "grammar": "lsp",
          "label": "propTypeNumber",
          "matches": {
            "ptn": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.number.isRequired,",
          "doc": "Number prop type required",
          "grammar": "lsp",
          "label": "propTypeNumberRequired",
          "matches": {
            "ptnr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.object,",
          "doc": "Object prop type",
          "grammar": "lsp",
          "label": "propTypeObject",
          "matches": {
            "pto": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.object.isRequired,",
          "doc": "Object prop type required",
          "grammar": "lsp",
          "label": "propTypeObjectRequired",
          "matches": {
            "ptor": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.string,",
          "doc": "String prop type",
          "grammar": "lsp",
          "label": "propTypeString",
          "matches": {
            "pts": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.string.isRequired,",
          "doc": "String prop type required",
          "grammar": "lsp",
          "label": "propTypeStringRequired",
          "matches": {
            "ptsr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.symbol,",
          "doc": "Symbol prop type",
          "grammar": "lsp",
          "label": "propTypeSymbol",
          "matches": {
            "ptsm": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.symbol.isRequired,",
          "doc": "Symbol prop type required",
          "grammar": "lsp",
          "label": "propTypeSymbolRequired",
          "matches": {
            "ptsmr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.any,",
          "doc": "Any prop type",
          "grammar": "lsp",
          "label": "propTypeAny",
          "matches": {
            "ptan": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.any.isRequired,",
          "doc": "Any prop type required",
          "grammar": "lsp",
          "label": "propTypeAnyRequired",
          "matches": {
            "ptanr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.node,",
          "doc": "Anything that can be rendered: numbers, strings, elements or an array",
          "grammar": "lsp",
          "label": "propTypeNode",
          "matches": {
            "ptnd": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.node.isRequired,",
          "doc": "Anything that can be rendered: numbers, strings, elements or an array required",
          "grammar": "lsp",
          "label": "propTypeNodeRequired",
          "matches": {
            "ptndr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.element,",
          "doc": "React element prop type",
          "grammar": "lsp",
          "label": "propTypeElement",
          "matches": {
            "ptel": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.element.isRequired,",
          "doc": "React element prop type required",
          "grammar": "lsp",
          "label": "propTypeElementRequired",
          "matches": {
            "ptelr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.instanceOf($0),",
          "doc": "Is an instance of a class prop type",
          "grammar": "lsp",
          "label": "propTypeInstanceOf",
          "matches": {
            "pti": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.instanceOf($0).isRequired,",
          "doc": "Is an instance of a class prop type required",
          "grammar": "lsp",
          "label": "propTypeInstanceOfRequired",
          "matches": {
            "ptir": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.oneOf(['$0']),",
          "doc": "Prop type limited to specific values by treating it as an enum",
          "grammar": "lsp",
          "label": "propTypeEnum",
          "matches": {
            "pte": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.oneOf(['$0']).isRequired,",
          "doc": "Prop type limited to specific values by treating it as an enum required",
          "grammar": "lsp",
          "label": "propTypeEnumRequired",
          "matches": {
            "pter": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.oneOfType([\n\t$0\n]),",
          "doc": "An object that could be one of many types",
          "grammar": "lsp",
          "label": "propTypeOneOfType",
          "matches": {
            "ptet": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.oneOfType([\n\t$0\n]).isRequired,",
          "doc": "An object that could be one of many types required",
          "grammar": "lsp",
          "label": "propTypeOneOfTypeRequired",
          "matches": {
            "ptetr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.arrayOf($0),",
          "doc": "An array of a certain type",
          "grammar": "lsp",
          "label": "propTypeArrayOf",
          "matches": {
            "ptao": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.arrayOf($0).isRequired,",
          "doc": "An array of a certain type required",
          "grammar": "lsp",
          "label": "propTypeArrayOfRequired",
          "matches": {
            "ptaor": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.objectOf($0),",
          "doc": "An object with property values of a certain type",
          "grammar": "lsp",
          "label": "propTypeObjectOf",
          "matches": {
            "ptoo": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.objectOf($0).isRequired,",
          "doc": "An object with property values of a certain type required",
          "grammar": "lsp",
          "label": "propTypeObjectOfRequired",
          "matches": {
            "ptoor": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.objectOf(PropTypes.shape($0)),",
          "doc": "An object whose keys are known ahead of time",
          "grammar": "lsp",
          "label": "propTypeObjectOfShape",
          "matches": {
            "ptoos": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.objectOf(PropTypes.shape($0)).isRequired,",
          "doc": "An object whose keys are known ahead of time required",
          "grammar": "lsp",
          "label": "propTypeObjectOfShapeRequired",
          "matches": {
            "ptoosr": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.shape({\n\t$0\n}),",
          "doc": "An object taking on a particular shape",
          "grammar": "lsp",
          "label": "propTypeShape",
          "matches": {
            "ptsh": true
          },
          "options": {}
        },
        {
          "content": "PropTypes.shape({\n\t$0\n}).isRequired,",
          "doc": "An object taking on a particular shape required",
          "grammar": "lsp",
          "label": "propTypeShapeRequired",
          "matches": {
            "ptshr": true
          },
          "options": {}
        },
        {
          "content": "getSnapshotBeforeUpdate(prevProps, prevState) {\n\t$0\n}\n",
          "doc": "Invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture current values",
          "grammar": "lsp",
          "label": "getSnapshotBeforeUpdate",
          "matches": {
            "gsbu": true
          },
          "options": {}
        },
        {
          "content": "static getDerivedStateFromProps(nextProps, prevState) {\n\t$0\n}\n",
          "doc": "Invoked after a component is instantiated as well as when it receives new props.",
          "grammar": "lsp",
          "label": "getDerivedStateFromProps",
          "matches": {
            "gdsfp": true
          },
          "options": {}
        },
        {
          "content": "componentDidCatch(error, info) {\n\t$0\n}\n",
          "doc": "Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.",
          "grammar": "lsp",
          "label": "componentDidCatch",
          "matches": {
            "cdc": true
          },
          "options": {}
        },
        {
          "content": "function mapDispatchToProps(dispatch) {\n\treturn {\n\t}\n\n}",
          "doc": "Adds the redux mapDispatchToProps function",
          "grammar": "lsp",
          "label": "dispatchRedux",
          "matches": {
            "disp": true
          },
          "options": {}
        },
        {
          "content": "useEffect(() => {\n$0\n})",
          "doc": "Adds use effect",
          "grammar": "lsp",
          "label": "useEffect",
          "matches": {
            "usf": true
          },
          "options": {}
        },
        {
          "content": "useEffect(() => {\n$0 return () => {\n$0\n\t}\n})",
          "doc": "Adds use effect",
          "grammar": "lsp",
          "label": "useEffectUnMount",
          "matches": {
            "usfu": true
          },
          "options": {}
        },
        {
          "content": "useEffect(() => {\n$0\n},[])",
          "doc": "Adds use effect",
          "grammar": "lsp",
          "label": "useEffectDidMount",
          "matches": {
            "usfd": true
          },
          "options": {}
        }
      ]
    }
  ],
  "vue-vscode-snippets/snippets": [
    {
      "nuxt-script": []
    },
    {
      "nuxt-script": [
        {
          "content": "async fetch ({ store, ${1:params} }) {\n\tlet { data } = await fetch('${2:endpoint}').then(res => res.json())\n\tstore.commit('${3:MUTATION_TYPE}', data)\n},",
          "doc": "Nuxt Fetch",
          "grammar": "lsp",
          "label": "Nuxt Fetch",
          "matches": {
            "nfetch": true
          },
          "options": {}
        },
        {
          "content": "this.$route.params.${1:id}",
          "doc": "Nuxt Route Params",
          "grammar": "lsp",
          "label": "Nuxt Route Params",
          "matches": {
            "nparam": true
          },
          "options": {}
        },
        {
          "content": "head () {\n\treturn {\n\t\ttitle: ${1:'Page Title'},\n\t\tmeta: [\n\t\t\t// hid is used as unique identifier. Do not use `vmid` for it as it will not work\n\t\t\t{ hid: 'description', name: 'description', content: ${2:'My custom description'} }\n\t\t]\n\t}\n},",
          "doc": "Nuxt Head",
          "grammar": "lsp",
          "label": "Nuxt Head",
          "matches": {
            "nhead": true
          },
          "options": {}
        }
      ]
    }
  ]
}